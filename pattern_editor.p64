picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTEzIDIxOjI5OjAxIixtb2RpZmllZD0iMjAyNS0w
My0wMyAyMDoxNDoyNCIscmV2aXNpb249MjE3N11dbHo0AGATAACdRwAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIANd5PTAsem9vbT0xMn0sPwDwCgcH
BBAnIAcvHgcABx4PFx4XDg0HDQ4XHg0RAF8uByAnEE8AJkAODxcOSwAQB1UAPw4NDlEAIv8GBgcE
EBogChcKEAoXCgAKNwq3ADcAQgAasQoJBDAZMAkACQAZBADQGRoZAAkQCQoXCgkQCVIAzwAJCgBX
AAqXAHcgV50AG9AQDARQCRAJsAkQCZAJVQBgAAlACRAJFABwEAkwOTAJIGkAIRAKEACRAAkACQoH
EAcKiwD-CCAKBzAHCiAZIApQCiAJ8AEJsAkgCZAJgAAe-wAACbAJ8HEJ0AnwAwlwCSA-ABtPEATw
8DIAGvIeDxIEUB8XsA4RDpAOAQcGAQ6ADiENAQ5gDgEsEQ5QDgEMFxwRDkAOAQwHDAEMCgBRIQwh
DjAIAMABBwEOIA4RHAEHEQYKAPAPAQ0BDAcRDQYNAQ4ADgEtIQ0GDQcNAR4BHQYtBg0WCgCRDQYH
FgcGDQYdIgCABwYNAQYHDSE7AEAFERUNYABfYQ5gbjD1ABvxAhIEYB8XwA4RDqAOAQYHAQ6QwwAR
cMMAE2DDABdQwwATEcMAFRHDAHIBBgEcEQcBxQBjBg0BDBcRxQBQPTEdBgfDAFAWPQYNFsIAFxbC
AGERBx0RBzE1ACIVAcAAT3EOYH7AABvwBBISBHAfF_AOEQ7ADgEWAQ6gDlGNARA8jAHyBgEMFywB
DmAeAQwHHAEMAR5ADiEMMYABQQcBDDG-AHUwDgEGEQcRhAFFBg0RF4UBAKsAUQ0xDQYNxgBxJg0G
PQYNJpMBCYsBUDEHARYBygD-Ax4BBgEFEQUBBgEeUA5xDoB_QIwBJwJPAnABDSEOgA4RxwChDhEM
FxwBDlAOEYwBIAEOzwAzIQwRzwADCgBQBgEHERyMARAQzQBjERcMAQ0GzADGHTE9AR4BFg0GPRYd
xQAiFg3DAEARHQcRkAJvDRUBFQYBjAEiEQ-AAAMPAyEGB0YCQQ0hDnDAABNQwAAVQMAAETDAABUB
wAAEjQEyARwRvgBSDREHDAGKAXENBw0GDSEtQwJYDQYtBh2GAQAiAEAhDQcGIQMSAcQAPhEFAQ8D
DwQEFQ8yALBPAQEEBzEAGr8DAwQABwAHDAcAB1AGGyADBjkAXzcMJzAHrgUbIgMIOQARFzsADz0A
IjBnDBexABAQBAAPgwF_8hAIEAQgGVAZQAkXCTAJFwkgCTcJEAk3CQAJBwoXCgcZBgAxGhcaBAD-
BQoJGgkKORpZGjkAOQAZEBkQCSAZvgYb8QEGEAQQGTAZMBkgCRoJEAkXBAAQANgHExkEAGApGjka
_QX3By8QGS8BGzEEEASVAAECANAACRoZFxkXGRoZGvkBFwAPgAgc0AoEMBdQVyB3EHcA9w5lCC9A
N_oADBk4QQDxBwwOBEAXkBeQF2AHEBcQByAXADcAFxAGAP8EIHcQBwB3AMcAlyB3MHdAV2A3MFoA
GWEODQQgB1ACAP8T8AcXsBdQB0AXQAcAByA3IAdAV3BXQAcQVxAHQFeAN6AXUFkAGUAQDgQwVQBh
NAfQB-AhVgCfcBfAN7A3wBdgSAAMD4UCHQ0xAPEAEB4QPhAeIA4RHjQeEQ4AogdABD8PBBgG8Qge
AQ0BBBwHLAQBDQEeEQIEDAccCQwEAicAcQgELBkMBAh_BfEOAg4EDDkMBA4CAR4BGAQHOQcEGAEe
AQIOCAQ3BAgWAJACCA4MNAwOCAJIAHEIAgweDAIISABkEQIOPA4CeQAzEhgSeAD-BCEyIQ0BHiEe
MR4hDgAuED4QLgDZABmAEhEEYD6gLjQdBwDOAJE_QA4BBB0HLQQPCZMCBA0HHQkNBAIJB6QIBC0Z
DQQIAQ8NzwBDDTkNBJcABNEAACkABtMAAQ4AUAgODTQN1QAAKACiBgECCAINHg0CCB4AUAwRAg49
RABAEA4hDtoAsBEOMC4ADgEyAQwG_wa-UQwBDoBOEQ7gHjDaAB5isB40HoAOqAEjDmDbAADSBgfb
ACYOMNkAJw4g1gACrgAD1wAAbQElDw3YABEMoAED1wACoAEE1QBDEQ4QHtMA8AYeMA4REhESEQ5g
HhEWER6QDgEcAQ6YCD-gHnDMABnwFBwbBLA_8AYeNB7wAw4UPw8UDvABDgR9BA7gDgQdFx0HCR0E
twmABA0nHQcZDQS_CQDhADEXLSnhAMGADgEIAgRNOQ0EAghNCFIIAgQtWQ4AwGAOARgCBA15DQQC
GF0IIAEIAAFQB1kdBA4fAPAAQA4RDgEOAgRHLQQCDgEO2ggA-gGROAIUNxQCOAEMJAHwDQwGESgN
EjQSDSgRBgwBHgEGDBEYHh0yHR4YEQw4ATAMIQIzAbEODRcNDgwCDggCITgA8A0hCQECCBIeFx4S
CAIBCSEOIB4xAhgeFx4YAjEe2wtyMRIIPQgSMdAIgAwHDDECOAIx9AgAhQDRDBcGDCEJMQkhDAYX
DEgC8QIGBwYMEQYMERwRDAYRDAYHBpwAMBwWDMgJEBdcCzAMFhyeAMMHHAEeIQwRDCEeARwmABAW
kQAgLjF3AiAMFmAAUCEOQD5ABgBMLvAALlcFYy0yLjg3NbEBYi0wLjEyNbYBHzFmBB4PMQCQD-kE
FyMPEPoEEQsoACEPDPsEEQpiATELDxz8BGEICwEeARpUA7EaAR4BCwgKBDcEChYA8QULCggHNAcI
CgsBHhELCgsHGAcLCkoAZBELCDcIC3wANBsaG-wEHzv8BEgjDxAiBBMM-QQhDwwlBBQL-gQxDA8c
KQQhCgyaABEb1AARGysAggwKCwQ3BAsKmQKBDAsKBzQHCgv1ArIBBgEMCwwHGgcMCx4Agw8NEQwK
NwoMAAUzHBscAAUyPAEIAAUfCAAFQQffACcOMN0AKA4g2gACsgAD2wACAwUF3ABFCAEeEdsAAAMB
FRHZAAEDBQLWAAADBTccERwDBR4YAwUPugI0D34D6xMDfQMRAycAIQ8bfQMRC8IBMQMPGn0DRQoD
AR6pAjMeAQPLAQAWAKADCwoPCjQICgsDSwBxCwMIGggDC0sAZBEDCjgKA3wANBMbE34DHzN_A0gT
A54CFAN9AxEboAIUDH0DANIAAKMCAqMAIQEc1AARHCsAkgMLDAQ3BAwLAw4AgwwLCjQKCwwDfQOU
AwwDChsKAwwDfQNTAws6CwN9AzMTHBN9Ax8zfQNKBt4AJw4w3AAoDiDZAAKxAAPaAAJ8AwXbABAK
pQEgDAuyASMLDKYBgQwDCBsIAwwDfQNRAws4CwN9AzcTERN9Ax8afQP-RSkPGfsGEQl9AxMJ_gYS
H30DAOQGERnPAREZ7gZRCQQ3BAkWACILCX0DEQn7BnMJCwgaCAsJ_wZECjgKC3wALxsZ_wZTExmg
AgT7BhEJoQIWCfoGEh_kAgL6BgTUAALsBgHWAAPcBiEMCX0DFQn6BnYJDAobCgwJ_gY1CzoL_gYf
GfoGVBkZ_gYE3AAoDiDZAAKxAAPaAAP5BgTbAAB9AyIMCX0DEwn6BnMJDAgbCAwJ_gY_CzgL_gYP
fQP-GwDxGbMsIAwrDAAMCycLHAQAfwwADCsMICx1EQ0cNksA-wwgGDAIGQgQCAkXCRgJJwkYCRcJ
CBAIGQgwGCBLAB3xAxAtIA0GBwYNAA0GJwYdRx0GJwwAXwcGDSAtmAAb8QIFBQQACAkIAAgnCAkn
CQgnCA4AD0MAHe8QHRANBwYdJx0GBw0QHYIAH-8CHBAMCwcMAAwnDAAMBwsMEByCABvACQoEMCxA
DCcMIAwWQwDAFyYHHBcGJwYcBwZHBAC-DAAMBkcMEBwnDEC3ARzwAgoJBBBeIA4nBhcOAA4nJhce
VwD-CAceBwZHBg4ADgZHDiAORw4wDicOUC4gWQAd8AEgLlAOJw4wDhYHFg4gDhcWYwBDNwYnHgQA
IQ4AFAAvIF6yAA4PFgMeDzEA-------------1qnCAgErBFMARwBPAQAP0wRrEQAHGC8AVwRbAEC
AD9cIZyAACIwbAFcAgAfMT4AIz9cAXy6ACQUnPgAEjHAAA_AAB3fnDE8AWwhfAFsATwhrLwAID9s
IUx2ASYgnDE2AQIEAB_8WAIeDzEA----8GEICAR8AQwCAC-8ITkAHCP8IToAH3w5ABzvISxRLFE8
QTxBPFEsUSx3AB2TawErQSsBBh0BBQCfNisBDRENOzF7SAAcoRFbBjErBhEWARsFAK9GARsdEQ0B
G0GrSAAcUfsJCQobAwA0KQobCwA-IwqLRwAcS4FHBhEDAD8HRgFFABzRHTUtBTYFHQUGFQYFHQoA
IAcsBQBiHRUdBQcWBQAfDVQAICEGLVUAEA0GABQtVgBvNgUdVS1FTwAdIgtpAgAiG1kCAA8-ABwD
NgATG0YAHws-ABz-AfEEBh1BBh1BNjENEA0xMHE-ABxwcQZhBhEWIQQAj0YhHRANIUChQgAc75FX
EVcRVhFWEQ0QLSFAgAAdcQEGTREHNg0EAP8CXRFcEQ0FFgUNEQANFQ0AEVAtAh0TDRgCCB0CFh0U
AD9lHVVRABxAC5MLAwIAL-sfOQAcYFMbAyszOzoAHxk6ABwv_TAxAByyuzQbFDkbBEkLBFlCAg9A
AB0-dPkcMwAcv3s0OzkUG0kEG1kEtQIjwL0FDRUtBQEFER0FAQIA3x0RBSENFUENAQVBDWFMAB2p
FQ0lDQURBSEFAQIAL-EHSQAckX0VDQU9EQUBBZoAEAWUAM8FDTEFAR0xBQEFDWEXBB3xAwUNFQ0V
HRUNBQ0GBR0VDQYlHfUA-wINFQYVHQYFBgUNBQ01PQUtBVgAHS-4MKAEKC87OVUGHT-5JLsyABwD
bwAQC9UELzm7wwMeMFENYQIArx0FQR1RPQEFEX1CABx-8R4FEQURvTYAHDBhDVHkAb9BBR1RHSEF
DQEdAUQAHy-4MDEATR-7MQAeYwoDCwMrA8YEHwk_ABzFA2ELA0EHA1EHCwNRCgARQQQAD0oAHJtB
AxtRAwtBAxsJAA9HABz-CPsBQRsBBxEXAQsBBwEXIQNhAwETAQMR1AId-w6LIUsBBxE7AQchKxEH
AQcBGwEDAQcRKwNBKwELEZQAHRIrYgHxAHM1AyUUBQQFBAUkBaQCBAIAH3RLABz-CwsDSyNLAwUT
CwMLEwQFQwUURQIUUiRCNCIESQAcYBsDGwMLIxwBX-EZNwEXSAcdcPEZEwETARNGAA-1CR2A8QcD
URNRAwt8ADABAwuIAE8BE0sB6gEewPEAA2ETUQsDURMRE0gAjwEDCxMbAwFLRwAc8QD7AkEbARcR
BzEXAQdxAxEvAg8uAh2AuyE7EQcBKyEoAv8DBwEHERsRBwEDAQtBAysRAwErTQAcAxoCEhQIAB8S
DgAIIpIECAAPYQAjEDQGAP8GMhYFAgQSBiUyNQIEIhUiBEIEAgRSUQAdMgtTC8gBgBNbA3sDWwML
BAAAowIQM6cCD00AHJDrAVsBA0sBA1sDACETSwYAD0MAHEB7AWsDAwBxSxMBWwMBWwkADxcCHVBz
AVMRA6ECMBEDUV0CsRQBAxsDARIBMwESCgAfE7ECHy_DWyABMf8E_wADWyM7EwsDOwMbAztDKwMb
U4kAHW-yCHF8cXyICx3AIhQyRCIUQgEEQgEMdzBQAVwBDFEGAA9aASsREbkDAA4AERt_AxELGgAP
0wAd-wNLARNbAQNrAVsDAlsDAmsD_wBBABz-AhMBSwMBWwFrAgNbAgNbA-sHQAAe-wYTASMBMwED
AVMBAlMSUwITOyNbA3scASa-BFEEIhQiEzJDEiNFACkwAyIUXwGvIgEDCyMSARMLM7cCHwDcAxE7
qgJvJTMFJDVEvAYm8AIhIjECBBIRDAIEMhxSDAEMMkgREDxOEV8xDCE8EUcCKAAIKlAUIhMBIj4C
bxIjCwMBM_YAHR-8OAkdb-wKJwwH-LYAHX-8EQcMJ-wKNgAc8AxrBVsFDEsFBw07BQ0GDSsVDQYN
GwUtBg0LBR0RABEFAgAfBicMHU91fP0gMwAcgAVrDQVbHQVLcQBgOw0VDQUrWg2vGw01DQULDUUN
BU8AHBLxiA0jARUIAD-1APO4Ax1v8xALUxvTBAUhbwMSIxLzEDcAHP8C_wsFKwUtBS0FKwUrBSMF
IwWdAx0v8TAlDh4jBQ3lAVMtBg0FLQwADxQACg8LAh4f-ZYAHSoNZQIADz8AHG_NFQ0F-SN8ASEA
fgHfKw0DGwUrDSMFKwUDK0UAH687LQVrDTsjDQNbPwAg8AAHASsFGwEDLQUNAQM7BQtYBS8FA8AK
Iz8hV4EMAh_CLQcMBS0FBiU1ECAFDScQEBYMACANJgsAfzYVDUYFDVZYABxffHV99hg0ABz-BAfl
HVUWDUUmDTU2DSVGDRVWDQV2AB9wJh1GDRYNNgQALz2WPwAcUSsFA1sNAwA6BQMbGAIfe0sAKCEr
LQ0ATysjDQMWFx4QAHYKAKYCIAsDJBIjEwELAD8jBQuZDB9EKwUTS5UAF1sMAA_zAh05CwVWAwBf
ZQtjC2NEABw-9hh1mgUeOFYFCwMAAXcADyQDHSOWPRwCD38ADFBtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAxOjQ4OjI1Iixtb2RpZmllZD0iMjAyNS0w
My0wMyAyMDoxNDoyNCJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAwOjUxOjM1Iixtb2RpZmllZD0iMjAyNS0w
My0wMyAyMDoxNDoyNCIscmV2aXNpb249MTg1NV1dbHo0AGgAAABYEAAA8Ah7e2JtcD11c2VyZGF0
YSgiaTE2IiwzMgMALyIwAQD--------------------78QgiKSxoaWRkZW49ZmFsc2UscGFuX3g9
MAgA0nk9MCx0aWxlX2g9MTYKABB3CgCAem9vbT0xfX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAxOjQ4OjI1Iixtb2RpZmllZD0iMjAyNS0w
My0wMyAyMDoxNDoyNCJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAwOjUxOjM1Iixtb2RpZmllZD0iMjAyNS0w
My0wMyAyMDoxNDoyNCIscmV2aXNpb249MTg1NF1dbHo0AKAAAAALCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzPyA9AAA8QQP--sPD-AQD-6lD-----KQ==
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAxOjQ4OjI1Iixtb2RpZmllZD0iMjAyNS0w
My0wMyAyMDoxNDoyNCJdXQ==
:: draw.lua
--[[pod_format="raw",created="2024-11-08 00:54:54",modified="2025-03-03 20:14:24",revision=2307]]
function draw_pats()
	-- ui setup
	cls(18)
	
	-- grid area
	draw_grid(back_grid, 16, 100, 0, 200, 200)
	draw_grid(front_grid, 6, 100, 0 , 200, 200)

	
	local myang = 0
	if fireang == -99 then
		myang = atan2(pspr.y - enspr.y, pspr.x - enspr.x + x_offset)
	end
	
	line(enspr.x + sin(myang) * 8, enspr.y + cos(myang) * 8, enspr.x + sin(myang) * 11, enspr.y + cos(myang) * 11, 14)

		-- enemy	
	circ(enspr.x, enspr.y-scrolly, 4, 8)
	
		-- player
	circ(pspr.x + x_offset, pspr.y-scrolly, 4, 11)
	
		-- bullets
	for b in all(buls) do
		drawobj(b)
	end
	
	-- menu
		--background
	rectfill(0,0-scrolly,101,200-scrolly,1)
	line(102,0-scrolly,102,200-scrolly, 6)

	draw_menu()
end

function draw_table()
	cls(1)

	draw_menu()
--	if menu then
--		for _i = 1, #menu do
--			for _j = 1, #menu[_i] do
--				-- change color if cell is currently selected
--				local _c = menu[_i][_j].c or 22
--				if _i == cury and _j == curx then
--					_c = 7
--				end
--				
--				-- make copy of local cell we're working with
--				local mymenu = menu[_i][_j]
--				
--				-- print cell
--				bgprint(mymenu.w, mymenu.x, mymenu.y, _c) --*****
--				print(mymenu.text, mymenu.x, 1+mymenu.y, _c)
--				if _i == cury and _j == curx then
--					rect(mymenu.x-2, mymenu.y-2, mymenu.x+(#mymenu.w * 5), mymenu.y+11, _c)
--				end
--			end
--		end
--	end
end

function draw_grid(_grid, _col, _x, _y, _w, _h)
	
	for l in all(_grid) do
		-- vert
		line(l + _x, _y - scrolly - 10, l + _x, _y + _h + 10 - scrolly - 1, _col)
		
		-- hori
		line(_x - 10, _h - l - scrolly - 1, _x + _w + 10 ,_h - l - scrolly - 1, _col)
	end
end

function draw_menu()
	if menu then
		for _i = 1, #menu do
			for _j = 1, #menu[_i] do
				-- change color if cell is currently selected
				local _c = menu[_i][_j].c or 22
				if _i == cury and _j == curx then
					_c = 7
				end
				
				-- make copy of local cell we're working with
				local mymenu = menu[_i][_j]
				
				-- print cell
				bgprint(mymenu.w, mymenu.x, mymenu.y, _c) --*****
				print(mymenu.text, mymenu.x, 1+mymenu.y, _c)
				if _i == cury and _j == curx then
					rect(mymenu.x-2, mymenu.y-2, mymenu.x+(#mymenu.w * 5), mymenu.y+11, _c)
				end
				if _i == execy then
--					rect(mymenu.x-2, mymenu.y-2, mymenu.x+(#mymenu.w * 5), mymenu.y+11, 14)
					line(0,-10 + 13 * execy,0,1 + 13 * execy,14)
				end
			end
		end
	end
end
:: gamefunctions.lua
--[[pod_format="raw",created="2025-02-22 05:49:01",modified="2025-03-03 20:14:24",revision=447]]
function doshots(arr)
	for s in all(arr) do
		s.age = s.age + 1
		s.x = s.x + s.sx
		s.y = s.y + s.sy

		if s.y < -16 or s.y > 280 then
			del(arr, s)
		end
	end
end

function drawobj(obj)
	mspr(cyc(obj.age, obj.ani, obj.anis), obj.x, obj.y)
	if coldebug and obj.col then
		msprc(obj.col, obj.x, obj.y)
	end
end

function mspr(si, sx, sy, flip_x, flip_y)
	local ms = myspr[si]
	-- 1:i, 2:w, 3:h, 4:ox, 5:oy, 6:flip_x 7:flip_y
--	sspr(gfx[ms[1]].bmp, 0, 0, ms[2], ms[3], sx - ms[4], sy - ms[5], ms[2], ms[3], ms.flip_x or flip_x, ms.flip_y or flip_y)
	sspr(ms[1], 0, 0, ms[2], ms[3], sx - ms[4], sy - ms[5], ms[2], ms[3], ms[6] or flip_x, ms[7] or flip_y)
	if ms.nextspr then
		mspr(ms.nextspr, sx, sy)
	end
end

function cyc(age, arr, anis)
	anis = anis or 1
	return arr[(age\anis) % #arr + 1]
end


:: input.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAzOjQ5OjI4Iixtb2RpZmllZD0iMjAyNC0x
MS0wOCAwNDowNjozOCIscmV2aXNpb249MV1dbHo0ABcAAAAVAAAA8AZ7ezAsMSwyLDN9LHs0LDUs
Niw3fX0=
:: io.lua
--[[pod_format="raw",created="2024-11-08 01:03:28",modified="2025-03-03 20:14:24",revision=1495]]
-- warning, export overwrites all of output_file every time it's used!
-- can store everything directly as variables, a lot of interesting uses i can think of

function export(auto)
	store(output_file,data)
	if auto then
		add(msg,{text="autosave",t=60})
	else
		add(msg,{text="Exported!",t=120})
	end
end


:: main.lua
--[[pod_format="raw",created="2024-11-08 00:51:35",modified="2025-03-03 20:14:24",revision=2125]]
include("draw.lua")
include("update.lua")
include("tools.lua")
include("io.lua")
include("ui.lua")
include("gamefunctions.lua")
include("pats.lua")

function _init()
	autosave = true
	dirty = false
--	printh("new run")
	
	modify_text_display = create_gui()
	visual_area = create_gui()
	
	window{width = 300, height = 200, title = "pat editor"}
	
	input_file = "/shmup/pats.pod"
	output_file = "/shmup/pats.pod"
	data = fetch(input_file)
	pats = data

	myspr = fetch("/shmup/myspr.pod")
	anilib = fetch("/shmup/anilib.pod")
	gfx = fetch("/shmup/gfx/spr.gfx")
	
	debug = {}
	msg = {}
	_drw = draw_pats
	_upd = update_pats
	menuitem(1, "export", export)
	
	curx = 1
	cury = 1
	scrolly = 0
	scrollx = 0
	scrollspeed = 4
	
	selpat = 1
	
	front_grid = {}
	back_grid = {}
	
	x_offset = 100
	
	pspr = {
		x = 100,
		y = 180,
	}
	
	enspr = {
		x = 100,
		y = 100,
		bulq = {},
	}
	
	buls = {}
	
	fireang = -99
	
	-- medium
--	data[1] = {
--		"base", -- name
--		0,      -- ang
--		1,      -- speed
--		11,     -- ani
--		3,      -- ani speed
--		40,     -- collision (basic medium bullet sprite)		
--	}
--	-- small
--	data[2] = {
--		"base", -- name
--		0,      -- ang
--		1,      -- speed
--		12,     -- ani
--		3,      -- ani speed
--		40,     -- collision (basic medium bullet sprite)		
--	}
--	-- large
--	data[3] = {
--		"base", -- name
--		0,      -- ang
--		1,      -- speed
--		13,     -- ani
--		3,      -- ani speed
--		40,     -- collision (basic medium bullet sprite)		
--	}
end

function _draw()
	_drw()
	
	if current_page == "edit" then
		modify_text_display:draw_all()
	elseif current_page == "newline" then
		modify_text_display:draw_all()
	end
	
	if #msg > 0 then
		if msg[1].text == "autosave" then
			rectfill(2, 2, 8, 9, 0)
			print("\^:0d1d11111f000000", 3, 3, sin(time() * 3) > -0.3 and 6 or 5)
		else
			bgprint(msg[1].text,240-(#msg[1].text*2.5),97,14)
		end
		msg[1].t = msg[1].t - 1
		if msg[1].t <= 0 then
			deli(msg,1)
		end
	end
	
	-- debug --
	cursor(4, 4)
	color(8)
	for txt in all(debug) do
		print(txt)
	end
end

function _update()
	_upd()
	modify_text_display:update_all()
	
	if time()%2 == 0 then
		if autosave and dirty then
			export(true)
			dirty = false
		end
	end
end

:: myspr.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTIwIDIyOjE5OjIyIixtb2RpZmllZD0iMjAyNC0x
MS0yMyAwMjo0Mjo1MSIscmV2aXNpb249NF1dbHo0AAEBAABuAQAA8AV7ezgsMTUsMTgsNSw4fSx7
OSwxNg4AETcOACAxMAwAQjE4LDgPABoxHgATMjsAAh4AQDI0LDggADAzLDAOADA1LDYOABIyDgAw
Niw0DgASMQ4AIDcsWgBQMCw1LDkPACA4LEsAEDQxABAzEAAQOQ0AwTEzLDcsMTJ9LHszMDsAAV8A
ACAAQDE3LDFKAAFMAGMxOCwzLDNZAGMxOSwzLDYNAGQyMCwzLDgNABcxDQAhMzJRABM2uQAgMzPF
AEIxNyw5DwAZNA8AUDEsNyw3ZAAARgAHDAAAaQATN_0AEDTNAEA5LDUsrwARNV0AgTIsOCw1fSx7
CwCAMTIsNiw2fX0=
:: out.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDA0OjAxOjE4Iixtb2RpZmllZD0iMjAyNC0x
MS0yMSAwMjoyNTozNCIscmV2aXNpb249M11dbHo0ABMBAAB-AQAA8AV7ezgsMTUsMTgsNSw4fSx7
OSwxNg4AETcOACAxMAwAQjE4LDgPABoxHgATMjsAAh4AQDI0LDggADAzLDAOADA1LDYOABIyDgAw
Niw0DgASMQ4AIDcsWgBQMCw1LDkPACA4LEsAEDQxABAzEAAQOQ0AwTEzLDcsMTJ9LHszMDsAAV8A
ACAAQDE3LDFKAAFMAGMxOCwzLDNZAGMxOSwzLDYNAGQyMCwzLDgNABcxDQAhMzJRABM2uQAgMzPF
AEIxNyw5DwAZNA8AUDEsNyw3ZAAARgAHDAAAaQATN_0AEDTNAEA5LDUsrwARNV0AgTIsOCw1fSx7
CwDwCjEyLDYsNn0seyI1MCIsIjEiLDAsMCwwfX0=
:: pats.lua
--[[pod_format="raw",created="2025-02-22 05:55:30",modified="2025-03-03 20:14:24",revision=539]]
function pat_shoot(en, pat, pang)
	if pang == -99 then
		pang = atan2(pspr.y - en.y, pspr.x - en.x + x_offset)
	end

	local mybuls = make_pat(pat, pang)
	
	for b in all(mybuls) do
		add(en.bulq,b)
	end
end

function dobulq(en)
	for b in all(en.bulq) do
		if b.wait <= 0 then
			b.x += en.x
			b.y += en.y
			b.sx = sin(b.ang) * b.spd
			b.sy = cos(b.ang) * b.spd
			
			add(buls,b)
			del(en.bulq,b)
		else
			b.wait -= 1
		end
	end
end

function make_pat(pat, pang)
	local mypat = pats[pat]
	local pattype = mypat[1]
	local ret = {}
	
	if pattype == "base" then
		add(ret, {
			age = 0,
			x = 0,
			y = 0,
			ang = pang,
			spd = mypat[2],
			ani = anilib[mypat[3]],
			anis = mypat[4],
			col = mypat[5],
			wait = 0,
		})
	elseif pattype == "some" then
		if rnd() < mypat[3] then
			ret = make_pat(mypat[2], pang)
		end
	elseif pattype == "sprd" then
		for i = mypat[3], mypat[4], mypat[5] do
			local nxpat = make_pat(mypat[2], pang + (i - 1) * mypat[6])
			for p in all(nxpat) do
				p.wait += (i - 1) * mypat[8]
				p.spd += (i - 1) * mypat[7]
				add(ret, p)
			end
			if i > 1 and mypat[9] > 0 then
				local nxpat = make_pat(mypat[2], pang + (i - 1) * -mypat[6])
				for p in all(nxpat) do
					p.wait += (i - 1) * mypat[8]
					p.spd += (i - 1) * mypat[7]
					add(ret, p)
				end
			end
		end
--	elseif pattype == "rapd" then
--		for i = 1, mypat[3] do
--			local nxpat = make_pat(mypat[2], pang)
--			for p in all(nxpat) do
--				p.wait += mypat[4] * (i - 1)
--				add(ret, p)
--			end
--		end
	elseif pattype == "brst" then
		for i = 1, mypat[3] do
			local nxpat = make_pat(mypat[2], pang + spread_rand(mypat[4]))
			local random_wait = flr(rnd(mypat[6]))
			local random_speed = rnd(mypat[5])
			for p in all(nxpat) do
				p.wait += random_wait
				p.spd += random_speed
				add(ret, p)
			end
		end
	elseif pattype == "comb" then
		for i = 2, 6 do
			if mypat[i] > 0 then
				local nxpat = make_pat(mypat[i], pang) 
				for p in all(nxpat) do
					add(ret, p)
				end
			end
		end
	end
	
	return ret
end

function newpat(pat_type)
	if pat_type == "base"  then
		return {
			"base",
			1,
			11,
			3,
			40,
		}
	elseif pat_type == "some" then
		return {
			"some",
			1,
			0.5,
		}
	elseif pat_type == "sprd" then
		return {
			"sprd",
			1,	-- bullet type
			1, -- starting val
			1, -- ending val
			1, -- step
			0.1, -- offset angle for copies
			0, -- offset bullet speed of copies
			0, -- offset spawn time of copies
			0, -- mirror pattern
		}
--	elseif pat_type == "rapd" then
--		return {
--			"rapd",
--			1,	-- bullet type
--			1, -- # of copies
--			2, -- delay
--		}
	elseif pat_type == "brst" then
		return {
			"brst",
			1,	-- bullet type
			1, -- # of bullets
			0.5, -- range of angle
			0, -- range of speed
			5, -- range of time
		}
	elseif pat_type == "comb" then
		return {
			"comb",
			1,	-- bullet type
			0, -- # of bullets
			0, -- range of angle
			0, -- range of speed
			0, -- range of time
		}
	else
		return {
			pat_type,
		}
	end
end

:: test.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAzOjI1OjQ0Iixtb2RpZmllZD0iMjAyNC0x
MS0wOCAwMzo1MDo0MCIscmV2aXNpb249MTddXWx6NAAJAAAACAAAAIB7Nyw4LDEwfQ==
:: test.txt
--[[pod_format="raw",created="2024-11-08 02:37:45",modified="2024-11-08 02:37:49",revision=2]]
test="useful data"
:: tools.lua
--[[pod_format="raw",created="2024-11-08 00:58:52",modified="2025-03-03 20:14:24",revision=1928]]
function bgprint(txt,x,y,c)
	print("\#0"..txt,x,y,c)
end

function fillBG(self, col)
	rectfill(1,1,self.width-2,self.height-2,col)
end

function fillSELECTED(self, col)
	rectfill(-1,-1,self.width+1,self.height+1,col)
end

function removeAllChildren(el)
	for child in all(el.child) do
		el:detach(child)
	end
end

function dump(o)
   if type(o) == 'table' then
      local s = '{ '
      for k,v in pairs(o) do
         if type(k) ~= 'number' then k = '"'..k..'"' end
         s = s .. '['..k..'] = ' .. dump(v) .. ','
      end
      return s .. '} '
   else
      return tostring(o)
   end
end

function print_table(node)
    local cache, stack, output = {},{},{}
    local depth = 1
    local output_str = "{\n"

    while true do
        local size = 0
        for k,v in pairs(node) do
            size = size + 1
        end

        local cur_index = 1
        for k,v in pairs(node) do
            if (cache[node] == nil) or (cur_index >= cache[node]) then

                if (string.find(output_str,"}",output_str:len())) then
                    output_str = output_str .. ",\n"
                elseif not (string.find(output_str,"\n",output_str:len())) then
                    output_str = output_str .. "\n"
                end

                -- This is necessary for working with HUGE tables otherwise we run out of memory using concat on huge strings
                table.insert(output,output_str)
                output_str = ""

                local key
                if (type(k) == "number" or type(k) == "boolean") then
                    key = "["..tostring(k).."]"
                else
                    key = "['"..tostring(k).."']"
                end

                if (type(v) == "number" or type(v) == "boolean") then
                    output_str = output_str .. string.rep('\t',depth) .. key .. " = "..tostring(v)
                elseif (type(v) == "table") then
                    output_str = output_str .. string.rep('\t',depth) .. key .. " = {\n"
                    table.insert(stack,node)
                    table.insert(stack,v)
                    cache[node] = cur_index+1
                    break
                else
                    output_str = output_str .. string.rep('\t',depth) .. key .. " = '"..tostring(v).."'"
                end

                if (cur_index == size) then
                    output_str = output_str .. "\n" .. string.rep('\t',depth-1) .. "}"
                else
                    output_str = output_str .. ","
                end
            else
                -- close the table
                if (cur_index == size) then
                    output_str = output_str .. "\n" .. string.rep('\t',depth-1) .. "}"
                end
            end

            cur_index = cur_index + 1
        end

        if (size == 0) then
            output_str = output_str .. "\n" .. string.rep('\t',depth-1) .. "}"
        end

        if (#stack > 0) then
            node = stack[#stack]
            stack[#stack] = nil
            depth = cache[node] == nil and depth + 1 or depth - 1
        else
            break
        end
    end

    -- This is necessary for working with HUGE tables otherwise we run out of memory using concat on huge strings
    table.insert(output,output_str)
    output_str = table.concat(output)

    print(output_str)
end

function dogrid(grid, spacing, speed, x_orientation, y_orientation)
	if #grid == 0 then
		for i = -spacing, 226, spacing do
			add(grid, i)
		end
	else
		updategrid(grid, spacing, speed, x_orientation, y_orientation)
	end
end

function updategrid(grid, spacing, speed, x_orientation, y_orientation)
	for l = 1, #grid do
		local addline = false
		if #grid == l and grid[l] <= 210 then
			del(grid, grid[1])
			add(grid, 210 + spacing)
		end
		
		grid[l] -= speed
	end
end

function do_mouse()
	wheel_y = ({mouse()})[5]
	
	prev_mouse_b = mouse_b or 0 -- for single clicks
	old_mouse_x = mouse_x or nil
	old_mouse_y = mouse_y or nil
	
	mouse_x,mouse_y,mouse_b = mouse()
	
	mousemoved = false
	if mouse_x != old_mouse_x or mouse_y != old_mouse_y then
		mousemoved = true
	end
		
	lc, rc, mc = mb_state(mouse_b, prev_mouse_b)
end

function mb_state(m, m_prev)
	if not m or not m_prev then return end
	
	mlb = m & 1 > 0
	mrb = m & 2 > 0
	mmb = m & 4 > 0
	
	pmlb = m_prev & 1 > 0
	pmrb = m_prev & 2 > 0
	pmmb = m_prev & 4 > 0
	
	if mlb and pmlb then
		left_mouse = "held"
	elseif mlb and not pmlb then
		left_mouse = "clicked"
	elseif not mlb and pmlb then
		left_mouse = "released"
	elseif not mlb and not pmlb then
		left_mouse = "up"
	end
	
	if mrb and pmrb then
		right_mouse = "held"
	elseif mrb and not pmrb then
		right_mouse = "clicked"
	elseif not mrb and pmrb then
		right_mouse = "released"
	elseif not mrb and not pmrb then
		right_mouse = "up"
	end
	
	if mmb and pmmb then
		middle_mouse = "held"
	elseif mmb and not pmmb then
		middle_mouse = "clicked"
	elseif not mmb and pmmb then
		middle_mouse = "released"
	elseif not mmb and not pmmb then
		middle_mouse = "up"
	end
	
	return left_mouse, right_mouse, middle_mouse
end

-- returns a random value inclusively between low and high
function rndrange(low, high)
	return flr(rnd(high + 1 - low) + low)
end

-- alternate to sgn, different in that 0 returns 0 instead of 1
function mysgn(v)
	return v == 0 and 0 or sgn(v)
end

-- takes an integer input and returns a string of length _num consisting of spaces
function width_to_string(_num)
	local _out = ""
	for i = 0,_num+1 do
		_out ..= " "
	end
	return _out
end

-- pads string v to length l with character ch
function pad_string(v, l, ch)
	local sv = tostr(v)
	
	if #sv < l then
		local diff = l - #sv
		for i = 1, diff do
			sv = ch .. sv
		end
	end
	
	return sv
end

function copylist(org)
	local ret = {}
	for k, v in pairs(org) do
		ret[k] = v
	end
	return ret
end

function spread_rand(val)
	return (rnd(2)-1)*val
end
:: ui.lua
--[[pod_format="raw",created="2025-02-22 03:45:15",modified="2025-03-03 20:14:24",revision=544]]
function refresh_pats()
	menu = {}
	
	if selpat > #pats then
		add(menu, {{
			text = "< new pat >",
			w = "           ",
			cmd = "newpat",
			x = 2,
			y = 2,
			c = 14,	
		}})
		
		return
	end
	
	local mypat = pats[selpat]
	
	add(menu, {{
		text = "< pat " .. selpat .. " >",
		w = "         ",
		cmd = "pat",
		x = 2,
		y = 2,
		c = 14,	
	}})
	
	add(menu, {{
		text = mypat[1],
		w = "    ",
		cmd = "patedit",
		cmdy = selpat,
		cmdx = 1,
		x = 2,
		y = 16,
		c = 22,	
	}})
	
	local mycap
	
	if mypat[1] == "base" then
		mycap = {
			"speed:",
			"anim :",
			"anisp:",
			"colli:",
		}
	elseif mypat[1] == "some" then
		mycap = {
			"src:",
			"prc:",
		}
	elseif mypat[1] == "sprd" then
		mycap = {
			"src :",
			"from:",
			"to  :",
			"step:",
			"ang :",
			"spd :",
			"time:",
			"mirr:",
		}
--	elseif mypat[1] == "rapd" then
--		mycap = {
--			"src :",
--			"num :",
--			"time:",
--		}
	elseif mypat[1] == "brst" then
		mycap = {
			"src :",
			"num :",
			"ang :",
			"spd :",
			"time:",
		}
	elseif mypat[1] == "comb" then
		mycap = {
			"src1:",
			"src2:",
			"src3:",
			"src4:",
			"src5:",
		}
	else
		mycap = {}
		for i = 2, #mypat do
			add(mycap, "p" .. i .. ":")
		end
	end
	
	for i = 2, #mypat do
		local row = {}
		add(row, {
			text = mycap[i-1],
			w = "      ",
			cmd = "",
			x = 2,
			y = 3 + (i * 13),
			c = 22,	
		})
		
		local pattext = pad_string(tostr(mypat[i]), 4, " ")
		add(row, {
			text = pattext,
			w = width_to_string(#pattext),
			cmd = "patedit",
			cmdy = selpat,
			cmdx = i,
			x = 33,
			y = 3 + (i * 13),
			c = 22,	
		})
		
		add(menu, row)
	end
	
	add(menu, {{
		text = "delete",
		w = "      ",
		cmd = "delpat",
		cmdy = selpat,
		x = 2,
		y = 6 + ((#mypat + 1) * 13),
		c = 22,	
	}})
end

function refresh_table()
	menu = {}
	for i = 1, #data do
		local row = {}
		add(row, {
				text = i,
				cmd = "",
				x = 2,
				y = -11 + 13 * i,
				w = "   ",
				c = 18,
			})
		for j = 1, #data[i] do
			add(row, {
				text = data[i][j],
				cmd = "edit",
				cmdx = j,
				cmdy = i,
				x = -43 + 32 * (j + 1),
				y = -11 + 13 * i,
				w = "      ",
			})
		end
		if cury == i then
			add(row, {
				text = " + ",
				cmd = "newcell",
				cmdy = i,
				x = -43 + 32 * (#data[i] + 2),
				y = -11 + 13 * i,
				w = "   ",
			})
		end
		add(menu, row)
	end
	add(menu,{{
		text = " + ",
		key = "_add",
		x = 2,
		y = -11 + 13 * (#data + 1),
		w = "   ",
		cmd = "newline",
		cmdx = j,
		cmdy = i,
	}})
end
:: update.lua
--[[pod_format="raw",created="2024-11-08 00:55:08",modified="2025-03-03 20:14:24",revision=2395]]
function update_pats()
	-- input handling
	refresh_pats()
	do_mouse()
	
	if mouse_x > 100 and mouse_x < 301 and mouse_y > 0 and mouse_y < 201 then
		window {cursor = 0}
	else
		window {cursor = 1}
	end
	
	enspr.x = mouse_x
	enspr.y = mouse_y
	
	if keyp("1") then
		if fireang == -99 then
			fireang = 0
		else
			fireang = -99
		end
	end
	
	--up
	if keyp("up") then
		cury = cury - 1
	end
	--down
	if keyp("down") then
		cury = cury + 1
	end
	cury = (cury-1) % (#menu) + 1
	cury = cury - wheel_y
	cury = mid(1, cury, #menu)
	
	if cury == 1 then
		if keyp("left") then
			selpat = selpat - 1
		end
		if keyp("right") then
			selpat = selpat + 1
		end
	end
	
	if cury <= 2 or cury == #menu then
		curx = 1
	elseif cury > 2 then
		curx = 2
	end
	selpat = mid(1, selpat, #pats + 1)

	-- selecting a cell
	if keyp("z") then
		mymenu = menu[cury][curx]
		-- editable cell selected
		if mymenu.cmd == "patedit" then
			current_page = "edit"
			text_bar = spawntextbox()
			_upd = upd_type	
			_prev_upd = update_pats
			text_bar:set_keyboard_focus(true)
			text_bar:set_text(tostr(mymenu.text))
			text_bar:select_all()
		elseif mymenu.cmd == "newpat" then
			add(pats,newpat("base"))
			dirty = true
			return
		elseif mymenu.cmd == "delpat" then
			deli(pats, selpat)
			add(msg,{text="pat deleted!",t=120})
			dirty = true
		end
	end
	
	-- extra processing
	dogrid(back_grid, 20, .15)
	dogrid(front_grid, 30, .25)
	
	-- shoot pattern
	if lc == "clicked" and selpat <= #pats then
		pat_shoot(enspr, selpat, fireang)
		
	end
	dobulq(enspr)
	doshots(buls)
end

function update_table()
	refresh_table()
	
	wheel_y = ({mouse()})[5]
	
	--up
	if keyp("up") then
		cury = cury - 1
	end
	--down
	if keyp("down") then
		cury = cury + 1
	end
	cury = (cury-1) % (#menu) + 1
	cury = cury - wheel_y
	cury = mid(1, cury, #menu)
	
	--left
	if keyp("left") then
		curx = curx - 1
	end
	--right
	if keyp("right") then
		curx = curx + 1
	end
	if cury < #menu then
		curx = (curx-2) % (#menu[cury]-1) + 2
	else
		curx = 1
	end
	
	local curmenu = menu[cury][curx]
	
	if curmenu then
		if curmenu.y + scrolly > (200 - 30) then
			scrolly = scrolly - scrollspeed
		end
		if curmenu.y + scrolly < 22 then
			scrolly = scrolly + scrollspeed
		end
		scrolly = min(0, scrolly)
		
		if curmenu.x + scrollx > (200 - 80) then
			scrollx = scrollx - scrollspeed
		end
		if curmenu.x + scrollx < 22 then
			scrollx = scrollx + scrollspeed
		end
		scrollx = min(0, scrollx)
		
		camera(-scrollx,-scrolly)
	end
	
	-- selecting a cell
	if keyp("z") then
		mymenu = menu[cury][curx]
		-- editable cell selected
		if mymenu.cmd == "edit" then
			current_page = "edit"
			text_bar = spawntextbox()
			_upd = upd_type	
			text_bar:set_keyboard_focus(true)
			text_bar:set_text(tostring(mymenu.text))
			mymenu.data = tonum(mymenu.data)
		-- newline cell selected
		elseif mymenu.cmd == "newline" then
			add(data, { 0 })
		elseif mymenu.cmd == "newcell" then
			add(data[mymenu.cmdy],0)
		end
	end
end

function upd_type()
	-- no need to check for input if we're typing
end

function spawntextbox(_i)
	local enter_mode = _i
	local editval
	local text_bar = modify_text_display:attach_text_editor{
		x = mymenu.x+14+scrollx, y = mymenu.y-1+scrolly,
		width = 30,
		height = 12,
		margin_top = 2,
		max_lines = 1,
		bgcol = 0, fgcol = 23,
		key_callback = {
			enter = function(enter_mode)
				editval = text_bar:get_text()[1]
				if mymenu.cmdx == 1 then
					-- tricky!!!
					if data[mymenu.cmdy][mymenu.cmdx] != editval and editval != "" then
						data[mymenu.cmdy] = newpat(editval)
--						data[mymenu.cmdy][mymenu.cmdx] = editval
					end
				else
					editval = tonum(editval)
					if editval == nil then
						editval = 0
					end
					data[mymenu.cmdy][mymenu.cmdx] = editval
				end
				dirty = true
				removeAllChildren(modify_text_display)
				current_page = nil
				_upd = _prev_upd
			end
		}
	}
	return text_bar
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTA4IDAxOjQ4OjI1Iixtb2RpZmllZD0iMjAyNS0w
My0wMyAyMDoxNDoyNCIscnVudGltZT0xMix3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzEyNSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZHJhdy5sdWEjMTUiLHdvcmtzcGFj
ZV9pbmRleD0xfSx7bG9jYXRpb249InVwZGF0ZS5sdWEjNzAiLHdvcmtzcGFjZV9pbmRleD0xfSx7
bG9jYXRpb249InRvb2xzLmx1YSMyMzIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InVp
Lmx1YSM4NCIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2FtZWZ1bmN0aW9ucy5sdWEj
MzIiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249InBhdHMubHVhIzE1OCIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0iaW8ubHVhIzQiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRp
b249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHtsb2NhdGlvbj0ibWFwLzAubWFwIix3
b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5zZngiLHdvcmtzcGFjZV9pbmRleD00
fX1dXQ==
:: [eoc]
