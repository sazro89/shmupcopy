picotron cartridge // www.picotron.net
version 2

:: 0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTA2IDE5OjIzOjQ1Iixtb2RpZmllZD0iMjAyNC0x
MC0wNyAwNzo0NDo0MCIscmV2aXNpb249Mzk2XV1sejQAfgAAABIxAADzIXtbMF09e2JtcD1weHUA
QyAQEATwVgcQB8AX0BfABxAH8FYsZmxhZ3M9MCxwYW5feAgAy3k9MCx6b29tPTh9LD4AH-AxAP--
-------------------------------------------------------------9dQbT04fX0=
:: blob.lua
--[[pod_format="raw",created="2024-10-06 05:10:33",modified="2024-10-07 07:44:40",revision=652]]
include "dither.lua"

function blob(p)
	local flr_r = flr(p.r)
	local _r = {
		0,
		flr_r * 0.05,
		flr_r * 0.15,
		flr_r * 0.30
	}
	
--	local pat = { -- we can also use dither_mask(value) values instead
--		0b0000000000000000,
--		0b0001101001011010,
--		0b0111111111111111,
--		0b1111111111111111
--	}

	local pat = {
		dither_mask(1),
		dither_mask(9/16),
		dither_mask(1/16),
		dither_mask(0)
	}

	if flr_r <= 5 then
		deli(_r,4)
		deli(_r,2)
		deli(pat,2)
		deli(pat,2)
--	elseif flr_r <= 6 then
--		deli(_r,3)
--		deli(pat,3)
	elseif flr_r <= 8 then
		deli(_r,4)
		deli(pat,3)
		pat[2]=0b1001001001001001	
	elseif flr_r >= 12 then
--		deli(_r,4)
--		deli(pat,3)
--		pat[2]=0b1001001001001001
		_r[2] = flr_r * 0.02
		_r[3] = flr_r * 0.08
		_r[4] = flr_r * 0.12
	end
--	fillp(dither_mask(3/8))
--	fillp(0b0001101001011010)
--	circfill(p.x-2,p.y+2, flr_r, 0x1814) -- adds dark outline
--	circfill(p.x-1,p.y+1, flr_r, 21) -- adds dark outline
	for i = 1, #_r do
--		poke(0x550b,0x3f) -- set black to transparent
--		palt()            -- recommended but what is this doing?
--		fillp(dither_mask(i/#_r))
		fillp(pat[i])
		circfill(p.x, p.y-_r[i], flr_r-_r[i], 0x0a09)
--		poke(0x550b,0x00) -- set back to black
	end
	
	fillp()
	if flr_r == 1 then
		pset(p.x, p.y, 0x0a09)
	elseif flr_r == 2 then
		rectfill(p.x-1, p.y-1, p.x+1, p.y+1, 0x090a)
	end
end


:: dither.lua
--[[pod_format="raw",created="2024-10-06 20:57:04",modified="2024-10-07 07:44:40",revision=331]]
local threshold_map = {
	0, 8, 2, 10,
	12, 4, 14, 6,
	3, 11, 1, 9,
	15, 7, 13, 5,
}

local function make_mask(value)
	local mask = 0
	for i = 1, 16 do
		mask = mask * 2
		if threshold_map[i] >= value then
			mask += 1
		end
	end
	return mask
end

local dither_masks = {}

for i = 0, 16 do
	dither_masks[i] = make_mask(i)
end

-- value 0-1
function dither_mask(value)
	return dither_masks[mid(0, flr(value * 16 + 0.5), 16)]
end
:: explode.lua
--[[pod_format="raw",created="2024-10-07 01:29:38",modified="2024-10-07 07:44:40",revision=173]]
function explode(ex, ey)
	add(parts, {
		x = ex,
		y = ey,
		r = 17,
		maxage = 2,
	})
	grape(ex, ey)
end

function dopart(p)
	-- [ ] age function
	-- [ ] max age counter

	if p.wait then
		-- wait countdown
		p.wait -= 1
		if p.wait >= 0 then
			p.wait = nil
		end
	else
		-- particle logic
		p.age = p.age or 0
    if p.age == 0 then
      p.ox = p.x
      p.oy = p.y
    end

		p.age += 1

		--movement
		if p.to_x then
			p.x += (p.to_x - p.x) / 4
			p.y += (p.to_y - p.y) / 4
		end
		if p.age >= p.maxage then
      if p.onend == "return" then
        p.onend = nil
        p.maxage += 10
        p.to_x = p.ox
        p.to_y = p.oy
      else
        del(parts, p)
      end
		end
	end
	-- 2 main ways to logic and animate
	-- sx/sy velocity system.  not great control if you want control over the particles final destination
	-- to_x/to_y destination definition
end

function grape(ex, ey)
	local spokes = 6
	local ang = rnd()
	local step = 1 / spokes
	local shakiness = rnd(4) - 2

	for i = 1, spokes do
		-- spawn blobs
		local myang = ang + step * i
		local dist = 8
		local dist2 = dist / 2

		add(parts, {
			x = shakiness + ex + sin(myang) * dist2,
			y = shakiness + ey + cos(myang) * dist2,
			r = shakiness + 6,
			to_x = shakiness + ex + sin(myang) * dist,
			to_y = shakiness + ey + cos(myang) * dist,
			maxage = 120,
      onend = "return"
		})
	end
	add(parts, {
		x = shakiness + ex,
		y = shakiness + ey - 4,
		r = shakiness + 10,
		maxage = 120,
	})
end

:: gfx/
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTA2IDE5OjIzOjQ1Iixtb2RpZmllZD0iMjAyNC0x
MC0xMSAwNDoxNjowOSJdXQ==
:: main.lua
--[[pod_format="raw",created="2024-10-06 04:41:06",modified="2024-10-07 07:44:40",revision=548]]
-- [x] flash / contrast flame
-- [ ] fireball
-- [ ] smoke

-- [ ] billowing (fire and smoke)
-- [ ] going up
-- [ ] smoke dissipates
-- [ ] sparks

include("blob.lua")
include("explode.lua")

function _init()
	parts = {}
	slowmo = false
	
	t = 0
end

function _draw()
	cls(12)
	for p in all(parts) do
		if p.wait == nil then
			blob(p)
		end
	end
--	print(myblb.r, 236, 250, 7)
--	print(dither_mask(1.1/16), 2, 2, 7)
	print(t, 2, 2, 7)
end

function _update()
	if btnp(4) then
		slowmo = false
		explode(240,135)
	end
	if btnp(5) then
		slowmo = true
		explode(240,135)
		t = 0
	end
	
	if slowmo == false or btnp(1) then
		t+=1
		for p in all(parts) do
			dopart(p)
		end
	end
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTA2IDA0OjM5OjU4Iixtb2RpZmllZD0iMjAyNC0x
MC0xMSAwNDoxNjowOSIscnVudGltZT0xMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImV4cGxvZGUubHVhIzM2Iix3b3Jrc3Bh
Y2VfaW5kZXg9MX0se2xvY2F0aW9uPSJibG9iLmx1YSM0OSIsd29ya3NwYWNlX2luZGV4PTF9LHts
b2NhdGlvbj0iZGl0aGVyLmx1YSM1Iix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSIwLmdm
eCIsd29ya3NwYWNlX2luZGV4PTJ9fV1d
:: [eoc]
