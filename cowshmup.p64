picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTEzIDIxOjI5OjAxIixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiIscmV2aXNpb249MTYwOV1dbHo0AIgPAADCQAAA8yF7WzBdPXtibXA9cHh1
AEMgEBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIANd5PTAsem9vbT0xMn0sPwDwCgcH
BBAnIAcvHgcABx4PFx4XDg0HDQ4XHg0RAF8uByAnEE8AJkAODxcOSwAQB1UAPw4NDlEAIv8GBgcE
EBogChcKEAoXCgAKNwq3ADcAQgAasQoJBDAZMAkACQAZBADQGRoZAAkQCQoXCgkQCVIAzwAJCgBX
AAqXAHcgV50AG9AQDARQCRAJsAkQCZAJVQBgAAlACRAJFABwEAkwOTAJIGkAIRAKEACRAAkACQoH
EAcKiwD-CCAKBzAHCiAZIApQCiAJ8AEJsAkgCZAJgAAe-wAACbAJ8HEJ0AnwAwlwCSA-ABtPEATw
8DIAGvIeDxIEUB8XsA4RDpAOAQcGAQ6ADiENAQ5gDgEsEQ5QDgEMFxwRDkAOAQwHDAEMCgBRIQwh
DjAIAMABBwEOIA4RHAEHEQYKAPAPAQ0BDAcRDQYNAQ4ADgEtIQ0GDQcNAR4BHQYtBg0WCgCRDQYH
FgcGDQYdIgCABwYNAQYHDSE7AEAFERUNYABfYQ5gbjD1ABvxAhIEYB8XwA4RDqAOAQYHAQ6QwwAR
cMMAE2DDABdQwwATEcMAFRHDAHIBBgEcEQcBxQBjBg0BDBcRxQBQPTEdBgfDAFAWPQYNFsIAFxbC
AGERBx0RBzE1ACIVAcAAT3EOYH7AABvwBBISBHAfF_AOEQ7ADgEWAQ6gDlGNARA8jAHyBgEMFywB
DmAeAQwHHAEMAR5ADiEMMYABQQcBDDG-AHUwDgEGEQcRhAFFBg0RF4UBAKsAUQ0xDQYNxgBxJg0G
PQYNJpMBCYsBUDEHARYBygD-Ax4BBgEFEQUBBgEeUA5xDoB_QIwBJwJPAnABDSEOgA4RxwChDhEM
FxwBDlAOEYwBIAEOzwAzIQwRzwADCgBQBgEHERyMARAQzQBjERcMAQ0GzADGHTE9AR4BFg0GPRYd
xQAiFg3DAEARHQcRkAJvDRUBFQYBjAEiEQ-AAAMPAyEGB0YCQQ0hDnDAABNQwAAVQMAAETDAABUB
wAAEjQEyARwRvgBSDREHDAGKAXENBw0GDSEtQwJYDQYtBh2GAQAiAEAhDQcGIQMSAcQAPhEFAQ8D
DwQEFQ8yALBPAQEEBzEAGr8DAwQABwAHDAcAB1AGGyADBjkAXzcMJzAHrgUbIgMIOQARFzsADz0A
IjBnDBexABAQBAAPgwF_8hAIEAQgGVAZQAkXCTAJFwkgCTcJEAk3CQAJBwoXCgcZBgAxGhcaBAD-
BQoJGgkKORpZGjkAOQAZEBkQCSAZvgYb8QEGEAQQGTAZMBkgCRoJEAkXBAAQANgHExkEAGApGjka
_QX3By8QGS8BGzEEEASVAAECANAACRoZFxkXGRoZGvkBFwAPgAgc0AoEMBdQVyB3EHcA9w5lCC9A
N_oADBk4QQDxBwwOBEAXkBeQF2AHEBcQByAXADcAFxAGAP8EIHcQBwB3AMcAlyB3MHdAV2A3MFoA
GWEODQQgB1ACAP8T8AcXsBdQB0AXQAcAByA3IAdAV3BXQAcQVxAHQFeAN6AXUFkAGUAQDgQwVQBh
NAfQB-AhVgCfcBfAN7A3wBdgSAAMD4UCHQ0xAPEAEB4QPhAeIA4RHjQeEQ4AogdABD8PBBgG8Qge
AQ0BBBwHLAQBDQEeEQIEDAccCQwEAicAcQgELBkMBAh_BfEOAg4EDDkMBA4CAR4BGAQHOQcEGAEe
AQIOCAQ3BAgWAJACCA4MNAwOCAJIAHEIAgweDAIISABkEQIOPA4CeQAzEhgSeAD-BCEyIQ0BHiEe
MR4hDgAuED4QLgDZABmAEhEEYD6gLjQdBwDOAJE_QA4BBB0HLQQPCZMCBA0HHQkNBAIJB6QIBC0Z
DQQIAQ8NzwBDDTkNBJcABNEAACkABtMAAQ4AUAgODTQN1QAAKACiBgECCAINHg0CCB4AUAwRAg49
RABAEA4hDtoAsBEOMC4ADgEyAQwG_wa-UQwBDoBOEQ7gHjDaAB5isB40HoAOqAEjDmDbAADSBgfb
ACYOMNkAJw4g1gACrgAD1wAAbQElDw3YABEMoAED1wACoAEE1QBDEQ4QHtMA8AYeMA4REhESEQ5g
HhEWER6QDgEcAQ6YCD-gHnDMABnwFBwbBLA_8AYeNB7wAw4UPw8UDvABDgR9BA7gDgQdFx0HCR0E
twmABA0nHQcZDQS_CQDhADEXLSnhAMGADgEIAgRNOQ0EAghNCFIIAgQtWQ4AwGAOARgCBA15DQQC
GF0IIAEIAAFQB1kdBA4fAPAAQA4RDgEOAgRHLQQCDgEO2ggA-gGROAIUNxQCOAEMJAHwDQwGESgN
EjQSDSgRBgwBHgEGDBEYHh0yHR4YEQw4ATAMIQIzAbEODRcNDgwCDggCITgA8A0hCQECCBIeFx4S
CAIBCSEOIB4xAhgeFx4YAjEe2wtyMRIIPQgSMdAIgAwHDDECOAIx9AgAhQDRDBcGDCEJMQkhDAYX
DEgC8QIGBwYMEQYMERwRDAYRDAYHBpwAMBwWDMgJEBdcCzAMFhyeAMMHHAEeIQwRDCEeARwmABAW
kQAgLjF3AiAMFmAAUCEOQD5ABgBMLvAALlcFYy0yLjg3NbEBYi0wLjEyNbYBHzFmBB4PMQD-----
-----------------3anCAgErBFMARwBPAQAP0wRrEQAHGC8AVwRbAECAD9cIZyAACIwbAFcAgAf
MT4AIz9cAXy6ACQUnPgAEjHAAA_AAB3fnDE8AWwhfAFsATwhrLwAID9sIUx2ASYgnDE2AQIEAB_8
WAIeDzEA----8GEICAR8AQwCAC-8ITkAHCP8IToAH3w5ABzvISxRLFE8QTxBPFEsUSx3AB2TawEr
QSsBBh0BBQCfNisBDRENOzF7SAAcoRFbBjErBhEWARsFAK9GARsdEQ0BG0GrSAAcUfsJCQobAwA0
KQobCwA-IwqLRwAcS4FHBhEDAD8HRgFFABzRHTUtBTYFHQUGFQYFHQoAIAcsBQBiHRUdBQcWBQAf
DVQAICEGLVUAEA0GABQtVgBvNgUdVS1FTwAdIgtpAgAiG1kCAA8-ABwDNgATG0YAHws-ABz-AfEE
Bh1BBh1BNjENEA0xMHE-ABxwcQZhBhEWIQQAj0YhHRANIUChQgAc75FXEVcRVhFWEQ0QLSFAgAAd
cQEGTREHNg0EAP8CXRFcEQ0FFgUNEQANFQ0AEVAtAh0TDRgCCB0CFh0UAD9lHVVRABxAC5MLAwIA
L-sfOQAcYFMbAyszOzoAHxk6ABwv_TAxAByyuzQbFDkbBEkLBFlCAg9AAB0-dPkcMwAcv3s0OzkU
G0kEG1kEtQIjwL0FDRUtBQEFER0FAQIA3x0RBSENFUENAQVBDWFMAB2pFQ0lDQURBSEFAQIAL-EH
SQAckX0VDQU9EQUBBZoAEAWUAM8FDTEFAR0xBQEFDWEXBB3xAwUNFQ0VHRUNBQ0GBR0VDQYlHfUA
-wINFQYVHQYFBgUNBQ01PQUtBVgAHS-4MKAEKC87OVUGHT-5JLsyABwDbwAQC9UELzm7wwMeMFEN
YQIArx0FQR1RPQEFEX1CABx-8R4FEQURvTYAHDBhDVHkAb9BBR1RHSEFDQEdAUQAHy-4MDEATR-7
MQAeYwoDCwMrA8YEHwk_ABzFA2ELA0EHA1EHCwNRCgARQQQAD0oAHJtBAxtRAwtBAxsJAA9HABz-
CPsBQRsBBxEXAQsBBwEXIQNhAwETAQMR1AId-w6LIUsBBxE7AQchKxEHAQcBGwEDAQcRKwNBKwEL
EZQAHRIrYgHxAHM1AyUUBQQFBAUkBaQCBAIAH3RLABz-CwsDSyNLAwUTCwMLEwQFQwUURQIUUiRC
NCIESQAcYBsDGwMLIxwBX-EZNwEXSAcdcPEZEwETARNGAA-1CR2A8QcDURNRAwt8ADABAwuIAE8B
E0sB6gEewPEAA2ETUQsDURMRE0gAjwEDCxMbAwFLRwAc8QD7AkEbARcRBzEXAQdxAxEvAg8uAh2A
uyE7EQcBKyEoAv8DBwEHERsRBwEDAQtBAysRAwErTQAcAxoCEhQIAB8SDgAIIpIECAAPYQAjEDQG
AP8GMhYFAgQSBiUyNQIEIhUiBEIEAgRSUQAdMgtTC8gBgBNbA3sDWwMLBAAAowIQM6cCD00AHJDr
AVsBA0sBA1sDACETSwYAD0MAHEB7AWsDAwBxSxMBWwMBWwkADxcCHVBzAVMRA6ECMBEDUV0CsRQB
AxsDARIBMwESCgAfE7ECHy_DWyABMf8E_wADWyM7EwsDOwMbAztDKwMbU4kAHW-yCHF8cXyICx3A
IhQyRCIUQgEEQgEMnClQAVwBDFEGAA9aASsREbkDAA4AERt_AxELGgAP0wAd-wNLARNbAQNrAVsD
AlsDAmsD_wBBABz-AhMBSwMBWwFrAgNbAgNbA-sHQAAe-wYTASMBMwEDAVMBAlMSUwITOyNbA3sc
ASa-BFEEIhQiEzJDEiNFACkwAyIUXwGvIgEDCyMSARMLM7cCHwDcAxE7qgJvJTMFJDVEvAYm8AIh
IjECBBIRDAIEMhxSDAEMMkgREDxOEV8xDCE8EUcCKBAEoQNAIhMBIj4CbxIjCwMBM_YAHR-8OAkd
b-wKJwwH-LYAHX-8EQcMJ-wKNgAc8AxrBVsFDEsFBw07BQ0GDSsVDQYNGwUtBg0LBR0RABEFAgAf
BicMHU91fP0gMwAcgAVrDQVbHQVLcQBgOw0VDQUrWg2vGw01DQULDUUNBU8AHBLxiA0jARUIAD-1
APO4Ax1v8xALUxvTBAUhbwMSIxLzEDcAHP8C_wsFKwUtBS0FKwUrBSMFIwWdAx0v8TAlDh4jBQ3l
AVMtBg0FLQwADxQACg8LAh4f-ZYAHSoNZQIADz8AHG_NFQ0F-SN8ASEAfgHfKw0DGwUrDSMFKwUD
K0UAH687LQVrDTsjDQNbPwAg8AAHASsFGwEDLQUNAQM7BQtYBS8FA8AKIz8hV4EMAh_CLQcMBS0F
BiU1ECAFDScQEBYMACANJgsAfzYVDUYFDVZYABxffHV99hg0ABz-BAflHVUWDUUmDTU2DSVGDRVW
DQV2AB9wJh1GDRYNNgQALz2WPwAcUSsFA1sNAwA6BQMbGAIfe0sAKCErLQ0ATysjDQMWFx4QAHYK
AKYCIAsDJBIjEwELAD8jBQuZDB9EKwUTS5UAF1sMAA_zAh05CwVWAwBfZQtjC2NEABw-9hh1mgUe
OFYFCwMAAXcADyQDHSOWPRwCD38ADFBtPTh9fQ==
:: gfx/anilib.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTE1IDIzOjA2OjA5Iixtb2RpZmllZD0iMjAyNC0x
Mi0xNiAwNjoyOTozNCIscmV2aXNpb249NF1dbHo0AFQAAABYAAAAgHt7MTMsMTQsBgARNQkAETYJ
APAIN30sezksMTAsMTEsMTJ9LHs2LDcsOCwXAPAHMjMsMjQsMjUsMjZ9LHsxOCwxOSwyMBkAsDEs
MjJ9LHsyN319
:: gfx/enemy-01.png
b64$iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8-9hAAAAAXNSR0IArs4c6QAAAYFJREFU
OI2NkzFLw1AUhb_Ekr-QyW7Bwf_gs1g7SFIqnbKIcwkEuoQsQqB0li6dgpWELG3pXP_DiGTTxd_Q
oXF4vfGl7eCBQN5955y8e3OewR5VsKgAjHhg6GvBYV3WdbGzSgH46roAZMVU1_PYIwB0nhEPjJaI
k2ef7fKdziplev6NM-YbBtnThNHnGQ8311zdXtB5nFAFi6olhO3yndl60xTbl1C8qROMfXiaMFpv
GsamvMzWG7xS29HEfPTrslcqbm1gxAND_o4KzeGEWOfIDEyZgVcCwfCP_dE-EoPieKUaZhUsqrqF
qCghTv6OfwipxUnjpLVBaFsQDHHyNpnXg95P48m8Hk7ehmCouHu00BEnysQ1lYkGZ_yDvVOcUwZz
C7AtojghzC2iFx-Sndp0TcL7V6KiJLQtxd3jKIleCdGdC65JA_mOME9rsfwF4zCJeh5kWNLz3KJO
4vBxwlfX5SiJQvRKGsOSL88OklgbyIaESloS6HXd5Ojq-vc6S_0XnbbNGOdESrIAAAAASUVORK5C
YII=
:: gfx/enemy-02.png
b64$iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAYAAADQWvz5AAAAAXNSR0IArs4c6QAAAYBJREFU
OI2VkzFrwkAUx-8n4ldw0i10yHewc6k6mESETFlKP0Ag4FBxKQTEuXTpFBATstTSuXbo4locstml
n6FDr8P5LneXKPQPR5J3--fLe7kXhjPi0YqrzyyesFPe5rnkrFhW9k7Bmqaxu0kBAMuLL7jTUDNn
94uTVTbq6BrE6sm4Ow2RFUt0N6lcBJYgqib4UYhWDyi24n4-lmHyJA_hhFUqmhcKqQaiet6eP2Ws
Uakm8suM-bgCAYQn_AEeX151kPamOCnbMkWxOJFVHfoeWDxhGmhmtYDIh5u3kQVDYPitrSwYws3b
QOQLr6LKHCFOBMxrCJgidxoC1q-wGCDwaMU7tsO37x_8Yzv8znI4x0Bcd2vOo5VYu7W217Edrs6U
rIhO4KkFwGphPvLEhld2Px95mOWp8BiSIDqBQ99Dd5MCeQrk5VHTNyEIfWTKZ9SeDMQTVjucR8jN
9RUuBzb824UGa1KymqDCTKmzo_XURo8yf1AAILjZ2r9Fp2jG-wAo-dIT4VkPIwAAAABJRU5ErkJg
gg==
:: gfx/enemy-03.png
b64$iVBORw0KGgoAAAANSUhEUgAAABIAAAARCAYAAADQWvz5AAAAAXNSR0IArs4c6QAAAYRJREFU
OI2Vky9vwkAYxn9ttn6FKXANAj-JJxiI0jIWVN0_AAkJhlSSLOgFg1jI-pTMDDIzA4iZ2QVRBwaL
RXATt956bUe2Sy7pvc_TX56_753BkSU6DyJ5NvpN4zfvyTHAJBrk1o8BNXOhXBehcy7Ex5O2Q_dc
FMp1kU4KYKYhxWnIoLTB7bZl0a4o3e22GZQ2FKdh5rfNNMTfJ1S7AtFCfq8aquzvycC0RABBlCDl
QDKeJEhL02n9qKtGBgLSk0kVN3exfBeCqhBUZaN3WyHu0PduK7Vv32L5rpqvxj9-_eTNtggcD7c-
ZkINd7TVgkz8Gu7zGXRa9J5DTl8_laZAw9krPkB-DJ0Wrmcy8WsayO22wT5Ij20xnL0qzUj2CORE
gmhPz7YI7i8hPEinZ9K7elTayJLl9YWH0W8aamrrCw_AkYWEOJ4C4Elb4HgZiJYoXulkMTjvHCfJ
BcUwkKMFGN-KG966vtFSpN9b5tHGhjjdPDGZdIo-r-iO-fZQ-w37C_QLffv1evDJCm8AAAAASUVO
RK5CYII=
:: gfx/myspr.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTExLTIwIDIyOjE5OjIyIixtb2RpZmllZD0iMjAyNS0w
MS0yMyAwMDozODozMSIscmV2aXNpb249MTZdXWx6NABMAQAAzgEAAPAFe3s4LDE1LDE4LDUsOH0s
ezksMTYOABE3DgAgMTAMAEIxOCw4DwAaMR4AEzI7AAIeAEAyNCw4IAAwMywwDgAwNSw2DgASMg4A
MDYsNA4AEjEOACA3LFoAUDAsNSw5DwAgOCxLABA0MQAQMxAAEDkNAMExMyw3LDEyfSx7MzA7AAFf
AAAgAEAxNywxSgABTABjMTgsMywzWQBjMTksMyw2DQBkMjAsMyw4DQAXMQ0AITMyUQATNrkAIDMz
xQBCMTcsOQ8AGTQPAFAxLDcsN2QAAEYABwwAAGkAEzftABA0zQBAOSw1LK8AETVdAOAyLDgsNX0s
ezYsIjE2IhAA8AEiOCIsNn0seyIzNSIsIjI4BQBiNyIsIjEzBQAAGwAAEAAxNCIsCAARMQwABBYA
JDE0BQARNwQAcH0sezAsIjYVAKA2IiwiMiIsMH19
:: gfx/ship.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTEzIDIxOjI1OjE4Iixtb2RpZmllZD0iMjAyNC0x
MC0xMyAyMToyNToxOCIscmV2aXNpb249MF1dbHo0AAcEAACpNgAA8yF7WzBdPXtibXA9cHh1AEMg
EBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIANp5PTAsem9vbT0xMn0sPwBP8gHtAgIA
CA9PAB1--QHWHQa9BQQAGz-F-QFoAB0pAg0CAF79AQL9DwMAD1YAHTEKEBoCAAQIACsaAAgAHxAi
AFMPuAAdL-DwMgCB8A1gEcABBwYBsCENAZABLBGAAQwXHBFwAQwHDAEMCABAIQwhYAYA8BkBBwFQ
ERwBBxEGAVABDQEMBxENBg0BMAEtIQ0GDQcNASABHQYtBg0WCgD-Dw0GBxYHBg0GHQEwAQcGDQEG
Bw0hUAEFERUNEXBhMKIAIS8GB6IABCBgEaIAIlARogCQQAEGARwRBwEGCgBgDQEMFxEGkAD0BD0x
HQYHARABHRY9Bg0WARABDRahAP8CIBEHHREHMUABBhUBFQ0RYHGfACKAFgGgUZABPAGcACAsAZwA
8AEcAQwBUCEMMQwhMAEHAQwxngBgMAEGEQcRQgEAIwExDREXQwEQACMB9gQGDTENBg0GBxEmDQY9
Bg0mER0GRQH-AwAxBwEWAQcxMAEGAQURBQEGAacAJPEEBwYBoAENIaARLAGAEQwXHAFwEUYBgAFg
IQwhDBFQqgABCADwAgYBBxEcAQYBMAENBhEXDAENswDgBwYdMT0BEAEWDQY9Fh1PAQKkAADzAc8x
BxEdBxFAEQ0VARWfACYvBgefAAkiAWCfACABYEcBQQEcEUBFATAHDAGHAnANBw0GDSEtWgFAFg0G
LdoBFQFEAWABMCENBwaXAr8BUBENFREFAXBhQI0DgQ8yABz-BQQGBAAfGAAOFx4XHh8XHh0OAB4A
QQAafwgIBCAH8Cw0AB_PUAcMB1AH8Bw6ACC-J0AHDAdAF9AH8AU_ACYDQgA-YAdAQwAiBUUAf1AH
YAdQB0DZAX7yEAgQBCAZUBlACRcJMAkXCSAJNwkQCTcJAAkHChcKBxkGADEaFxoEAP8GCgkaCQo5
GlkaOQA5ABkQGRAJIBkgbwAhAHEANRoJMHUAWAoXCgkQBgAxGRoZBAARWQIAbwkAGQAJMGsAJQxv
ADIwCRoEABI5AgBfQBlQGSBnAR7-BzcXsFeAd3B3YJdQl1CXYHeAV6A38BZHAB3xBGAX0BfQF6AH
EBcQB2AXADcAF1AGAP8AYHdQBwB3AAcwt0CXYHdwXgAkYPAEB1AHcD8D-xMLF9AXcAdAF0AHIAcg
NyAHYFeQV2AHEFcQB2BXoDfAF-AXXAAdEDBXAGE0B9AH8CFYAF9wF8A3sEoAIi-w8DIA--------
--------------------------------------------------VQPTEyfX0=
:: gfx/stage.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTEzIDIxOjI2OjIzIixtb2RpZmllZD0iMjAyNC0x
MC0xMyAyMToyNjoyMyIscmV2aXNpb249MF1dbHo0AP8BAABtNAAA8yF7WzBdPXtibXA9cHh1AEMg
EBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT04fSw_AE-yAe0CAgAI
D04AHH-9AdYdBr0FBAAbP8X9AWcAHCkCDQIAXv0BAv0PAwAPVQAcMQoQGgIABAgAKxoACAAfECIA
Uw_3ABwv8PAxAP-------6TH8gBdPxW9Pp0ePR59BABinV6dXt0eAgBvnT69Pv0GWAAzDwQABQ9k
ACIv8PDiAf8Uum0fFd0evT69Pt0eAgBvvV6dXv0F2gErAUgABwQAb91_fX79BFQAM2-9AB7dHn0j
Aimf8gA9HxUdHp0eBAAAMX59frEAAwIAD1wAIVN-FX1_fUAAEN1NARMADQAQfQ0AHwYGASUGUQAE
EgEPBQEtAKkAA1YAIx69BAAEAgAv-QiuASsInAAPsAAyyvBGDQ8VHbAeHbANDgQATy4N8DZNAB-h
HxUNsA4dDrAtDrAdDg1JAE8OLbA_SwAwIS0ODgAvDR6YACF1DxUNDg2wDgUAET5TAAMEAA9QACAg
PxXXAEEOLbAumQAvLQ4vASkESQAvDh3jAClJPxWwLXgBAwQAD5cAJgaOAA_aACsf8DEA--------
----------------------------------------vFBtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDEwOjQ5OjA5Iixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDA5OjIxOjQxIixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiIscmV2aXNpb249MjAxNl1dbHo0AMYMAABoQAAA-xZ7e2JtcD11c2VyZGF0
YSgiaTE2IiwxNiwyNTYsIjAwOWYwMDAzBAAjIzlmQAAfMQQAIQ9AAPtXMzIwMDMcAA_AAFofMwQA
IwVAAB8xBAAhDwAC-wESMAwAD4AAXh8zBAAjBUAAHzEEACEPAAL-ACIyOQwAD4AAXh8zBAAjBUAA
HzEEACEPAAL8UjEwMDI4DAAPgABZ42QwMDBkODAwZDQwMGQzCAAMEAAIGAAIMAAACAASZAwAEGUY
ABNiEAAXMBAAF2MYAARMABcwVAATOSQAW2EwMGMxEAATMAQACBgAGmIIAC9jOAQALFI5MDBjYZQA
I2NiEAAeORgADygABSdkNQwBFzQQAA4YAA8QAAMIFAAPCAAhCAwADwgAICNlMQQAFzMMAAQEAB4y
DAAPBAAaD1QAAQtMAG9hZDAwYWUIABAPFAABF2QkAgBUAhMx3AAWMhQADwQAFSdkMcgCCHwCD0AA
FQSgAg88ABwvZWEEACsESAAQYgQAD-gAIABEABBmiAGHNjAwYTcwMGYUAA8MABFnYzQwMGZiQAAA
HAMSYwgAAQwAFzUMAAMsAAgkAC9jNUAAABJkCAANTAAeZFgAAYgAFzlAABY4FAAPDAARBMgABUAA
DugADwABCwOUAAVAAAzoAB81zAALL2NjQAAAHjUoAA1YAB80AAEzBDwCImFmBAAuYjFIAhBlGAMX
NQQAHjYcAA8EAArAYzAwYjMwMGI0MDBiEAAWZUgAABwAEGXQAxI1BAArZWQEABNmQABAYjAwYggA
E2RAABNmCAADQAAFLAADCAArYjZAABM2DAAfZkAAAwQgAAWoAAOsACtiNiQAE2Q4ABpkQAAiYTU8
ACplYgQAI2I1JAATZjQABHgAH2ZAAAAHOAAFQAAfZEAABBpkQAAEoAAFKAEELAEbZkAAH2RAAAAI
HAAXZuwABBgAGmMcAA1AAAPAACZhNQwAD0AAAS9hNUAAEydlZgwAB0AAL2VkQAAHDgQAD4AAGwUs
AAwMAA9AABQmYTUgAAgMAAhAAAVcAA9AABwQZuwDFzUEAB42QAAPvAAGH2QgAAEPgAAYAIwBEzQY
AAgIABdmQAAaZjQACAwAARAAH2MIAAMIgAAFBAAIoAAPEAANHmUcAQ8EABpANjAwZoAAEjcEACJm
ZAgAJmEzDAAEGAAnZmYEAAMcACZmZagDJ2EzDAAXYgwAUmEwMGE5IAAJJAASOBgADjQADwQAAxRh
BAADRAAEWAAvZWIEABsXYQwADwQAcgTICAB0Bhoz9AsvYzAEAAADKAAFOAADyAsEUAAvYzgEAAsN
KAAfOQQABwUsAB85BAAIBJgAD6wACAUQAB8w4AAEHzFAABgfMTQADB4xQAAPMAAJL2VhBAAHBEAA
L2VhBAAIH2IEACsiZjMEAAgQAAwcAypmM-ACBAwALmYzMAAEFAAmZWIEAAQgAC5mM0AAKmFhHAAI
FAAvZWJAAAMIKAAvZjMYAAMvYTkUAAcEDAAuZjMcAAQUAC9lYsAACAcQAAwcAAxsAA9AAAEmZWI8
ACpmMxgADywABQgQAARgACZmM0gAImE5HAAMLAAMMAAMZAAPQAABJmFhEAAEFAAmZjMQACZlYjgA
L2ViBAAsH2EAAxciZjIkDiZmYRQAD3AOBSZhMkAAJ2EyJA4aZDQAK2QzRAAfMUAABy5jMWgOL2Ri
eA4AHzFAAAAPAAQEBMwMDAQAJmYxQAAPJAAJI2ZiTAATNAgAFjDUDAVAAAQkABdkCAADJAAE8AwE
OAABCAAfNUAAAAtgACJjMBgABMwMDZwAFzlAAA8kAAgPAAEyCJwAFjScAAVAABNiHAAIBAESNBgA
BRwAFzUgAA8AAQEIJAEDDAAPAAExL2MwBAAIA0AALmMwBAAPAA4KHjZAAA8oAAUEQAoJ3AkeZUAA
DygABS5lY3QKD0AABggoABpmQAAJBAAPQAAIDCgAK2VjlAAfZkAACAgkAAxAAAsYAA9AAAIfZEAA
DB9kQAAUH2RAAAAEVAAPQAANF2YIAARAAAQUAAcYAA9AAAIIKAAXZEAAD8ABLQhYAB9mQAALDCgA
K2VjFAAfZEAADAQkAA_ADAkPAAMAL2Y0gAwHImZmUAwjZTdgDA6AAA8oAAsAxBFIODAwYgQGC0AA
DygAAw8ABRMFYBQeMSASAZwEHjAEACtmYkAAAHgAEzkEAAiAAA-ABBAvYzAEAAcvYjEEAAQWMkAA
CbwADAQAHzkEAAQXYUAACLwADAQAGzAUARMxCAAWMEAABRAAHjAkAC5iOBQBKmIwwAANWAAPUAAI
BVQAH2GAAAgHBAAOFBgPCAAcCAwADwgAIQgMAA8IACEIDAAPCAAhDxQAAR8zCAAEHzgIAAALFAAN
_BoMABsLMAANPAAfYVQCAwk8Chc4CAAPPAAAJmFmBAArYjIcGRs4CAAIDAASMjwCCUAAA5gCD4AA
DQxEAAzUAi9kMQABFw2wCg8AARAIgAAiYzBEABdhDAAPAAESB0QAEGE4AB8xvAAMHzgUAAQLRAAP
vAAGGzQMAB84JBwEHzUgAAQbOAwADwgAICtjMGwBCAQAD0AEEC9lYSANBwRAAC9lYQQAByZjMAQA
I2Q5MAMfYYAAByZkMWABBBQAD8QAAh4xQAAOZAAPBAAMDEAADGQAHjCQHA8IAB0vYzAEAE8PNAEG
C9gADygABQ80ARUOKAAONAENEAAOBAAPLAAbAGwJEzcIAB82EAAEDBQACAwAAEQJE2YIAB9lEAAE
H2UgAAcvZTkEACsAcAEvZTgIACgDDAAPAAQqDmwBD4wBGwhIABswzA4fMAQAAQ9sACMOyAIPBAAY
H2PIAhAEuAAPjAAJA3wQL2MwpAAoHzEYAAcJpAAbYzAADKAAG2QgAA8EACAJpAgEeAAPVAAABZgA
CzAAL2M4BAAsBFgjGjRYIwkEAAwgAAcQACtkNaQJGjWEBgSUBgX4Ahs1EAAIDAALiAgvYzS8Bwwf
OBQAABszAAIPAAgZGzOAAAxUAh84CAAAD7wABQN8ACtjMIAAGjMwAA94AAkIBAAnZDn4AQhMAA54
AA8EAA4JkAAESAALNAEvYzBQAwQbY5AAD7wACC9kMRwADw0gAAdkAwVkAA88AAUeM7wADwQACg_Q
AQEIjAEfMjQABw_AAAYeOEQADzQAChc1PAATNAQAHzgIACgbOFAADAgAHzgIAAwONAAOCAAfOAgA
CBc4xAEfYqQCBAgIABs4CAAIAAIHOAEvZDlMAAgIRAAfM7wBCBIwVAAvZDlEAAgIgAAXMAQAHzHw
AQQIPAAXOBQAHzWIAAcPgAACBAgACzQABWwAHjKIACdjNBQABIgDGmM8ASdkORQAHzAEAAcFaAAI
bAAIYAAHjAMJlAAMaAAbOEQADwQAAA2UABtkgAAPRAABD7wIARtjkAAXODwAC0QAKmQxtAANgAME
MAAIDAAeOCQADxAAAggIAAgMAA8IACAnYzAEAAR4AQ8QAAUPGAABHzgEACwfOQQAKy9lYQQACxtm
lA4MBAAF7AEP7AABHzU8AgAeMBADDwQAGg5sAA4EAAdgAwgEAAlUAgekAA4sAA_oAAMPzAABJmQw
DAQPiAQCCHgAHzgIAAAEJAUEWAAbZMgAD4AEARMwPAAEKAAPBAAJHzVEAAQDCAAvYzCMAQADeAAM
BAArZDmwABNiHAAMQAEITAAA5BAWNLAaAQwBGzCEAQ8EAAwFPBgXZYQAA2gBL2VhBAAPATwYFjdY
GAicEg8EAAYHIAAjZmM0GAcwGA8EAD4fMUABBwlEAhs1CAAfNEwBEwkAAhc4CAAfOFgABBoynAAF
gAAbOAgADhQADggDD4AAEQ88AAgvY2REAAgPPAAFA-gCCAQAD8QAAgcMAw9MAQkFPAALMAAvZTEE
AAtmOWQwMDg3EAAPBAACHzJAAAwWNhAADjQAD0wACwFAABY1EAAPBAAdAUAAHjSQMA9AABoOOAAP
QAAbDuwADwQADxcyQAAEFAAPJAEBHzOAABAWMBAADAQADxQCAhowJAUFCAAfZDAAAAwkABdjxAII
FAQEAAMLMAAEHAAPMAABDhQADxAAAB826BMIDxQAEQ-wEwkfZgwABAcEACNkNgQAFzcMAAwEAB83
JAAHL2ViBAADJmRmDAAOHAAPMAAFDwQAHw1QBA8IAB0PFAABHzAYABgeNCQADywABg8oAAEPFAAB
HzQYABQfNCQAFA8gAAkPPAARD0QACQQUAA8IAAUfNAgABAQgAAgMAB80NAAUBRgA8RQiKSxoaWRk
ZW49ZmFsc2UsbmFtZT0ibWFwIixwYW5feD0zNAkA8gF5PTE2OTksdGlsZV9oPTE2CgAQdwoAgHpv
b209MX19
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDEwOjQ5OjA5Iixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiJdXQ==
:: prototypes/
:: prototypes/blob.lua
--[[pod_format="raw",created="2024-10-06 05:10:33",modified="2024-10-21 21:54:39",revision=1006]]
include("dither.lua")

function blob(p)
	local flr_r = flr(p.r)
	local _r = {
		0,
		flr_r * 0.05,
		flr_r * 0.15,
		flr_r * 0.30,
	}

	--	local pat = { -- we can also use dither_mask(value) values instead
	--		0b0000000000000000,
	--		0b0001101001011010,
	--		0b0111111111111111,
	--		0b1111111111111111
	--	}

	local pat = {
		dither_mask(1),
		dither_mask(9 / 16),
		dither_mask(1 / 16),
		dither_mask(0),
	}

	if flr_r <= 5 then
		deli(_r, 4)
		deli(_r, 2)
		deli(pat, 2)
		deli(pat, 2)
	--	elseif flr_r <= 6 then
	--		deli(_r,3)
	--		deli(pat,3)
	elseif flr_r <= 8 then
		deli(_r, 4)
		deli(pat, 3)
		pat[2] = 0b1001001001001001
	elseif flr_r >= 12 then
		--		deli(_r,4)
		--		deli(pat,3)
		--		pat[2]=0b1001001001001001
		_r[2] = flr_r * 0.02
		_r[3] = flr_r * 0.08
		_r[4] = flr_r * 0.12
	end
	--	fillp(dither_mask(3/8))
	--	fillp(0b0001101001011010)
	--	circfill(p.x-2,p.y+2, flr_r, 0x1814) -- adds dark outline
	--	circfill(p.x-1,p.y+1, flr_r, 21) -- adds dark outline
	for i = 1, #_r do
		--		poke(0x550b,0x3f) -- set black to transparent
		--		palt()            -- recommended but what is this doing?
		--		fillp(dither_mask(i/#_r))
		fillp(pat[i])
		circfill(p.x, p.y - _r[i], flr_r - _r[i], p.c)
		--		poke(0x550b,0x00) -- set back to black
	end

	fillp()
	if flr_r == 1 then
		pset(p.x, p.y, p.c)
	elseif flr_r == 2 then
		rectfill(p.x - 1, p.y - 1, p.x + 1, p.y + 1, p.c)
	end
end

:: prototypes/dither.lua
--[[pod_format="raw",created="2024-10-06 20:57:04",modified="2024-10-21 21:56:58",revision=680]]
local threshold_map = {
	0,
	8,
	2,
	10,
	12,
	4,
	14,
	6,
	3,
	11,
	1,
	9,
	15,
	7,
	13,
	5,
}

local function make_mask(value)
	local mask = 0
	for i = 1, 16 do
		mask = mask * 2
		if threshold_map[i] >= value then
			mask = mask + 1
		end
	end
	return mask
end

local dither_masks = {}

for i = 0, 16 do
	dither_masks[i] = make_mask(i)
end

-- value 0-1
function dither_mask(value)
	return dither_masks[mid(0, flr(value * 16 + 0.5), 16)]
end

:: prototypes/explmain.lua
--[[pod_format="raw",created="2024-10-06 04:41:06",modified="2024-11-30 22:44:55",revision=1382]]
-- [x] flash / contrast flame
-- [ ] fireball
-- [ ] smoke

-- colors for fireball progression
-- white/white 		0x0707		119
-- white/yellow 		0x070a		167
-- yellow/orange 	0x0a09		154
-- orange/yellow 	0x090a		169
-- pgrey/red 		0x0d08		141
-- pgrey/dark grey 0x0d05		93

-- [ ] billowing (fire and smoke)
-- [ ] going up
-- [ ] smoke dissipates
-- [ ] sparks

include("blob.lua")
include("explode.lua")
include("spark.lua")

function _init()
	parts = {}
	slowmo = false

	t = 0
end

function _draw()
	cls(12)
	for p in all(parts) do
		if p.wait == nil then
			p.draw(p)
		end
	end
	--	print(myblb.r, 236, 250, 7)
	--	print(dither_mask(1.1/16), 2, 2, 7)
	print(t, 2, 2, 7)
end

function _update()
	if btnp(4) then
		slowmo = false
		explode(240 + rnd(20) - 10, 135 + rnd(20) - 10)
	end
	if btnp(5) then
		slowmo = true
		explode(240, 135)
		t = 0
	end

	if slowmo == false or btnp(1) then
		t += 1
		for p in all(parts) do
			dopart(p)
		end
	end
end

function rndrange(low, high)
	return flr(rnd(high + 1 - low) + low)
end


:: prototypes/explode.lua
--[[pod_format="raw",created="2024-10-07 01:29:38",modified="2024-10-21 21:56:01",revision=635]]
function explode(ex, ey)
	add(parts, {
		draw = blob,
		x = ex,
		y = ey,
		r = 17,
		maxage = 2,
		c = 0x0707,
		ctab = { 0x0707, 0x070a },
	})

	sparkblast(ex, ey, 2)
	sparkblast(ex, ey, 15)

	grape(ex, ey, 2, 13, 1, "return", { 0x070a, 0x070a, 0x070a, 0x0a09 }, 0)
	grape(rndrange(ex - 2, ex + 2), ey - 5, 10, 20, 1, "return", { 0x070a, 0x0a09, 0x090a }, -0.2)
	grape(
		rndrange(ex - 3, ex + 3),
		ey - 10,
		25,
		25,
		0.2,
		"fade",
		{ 0x070a, 0x070a, 0x0a09, 0x090a, 0x0d08, 0x0d05 },
		-0.3
	)
end

function dopart(p)
	-- [ ] age function
	-- [ ] max age counter

	if p.wait then
		-- wait countdown
		p.wait = p.wait - 1
		if p.wait <= 0 then
			p.wait = nil
			if p.c == nil and p.ctab then
				p.c = p.ctab[1]
			end
		end
	else
		-- particle logic
		p.age = p.age or 0
		if p.age == 0 then
			p.ox = p.x
			p.oy = p.y
			p.r = p.r or 1
			p.ctabv = p.ctabv or 0
		end

		p.age = p.age + 1
		-- animate color
		if p.ctab then
			local life = (p.age + p.ctabv) / p.maxage
			local i = mid(1, flr(1 + life * #p.ctab), #p.ctab)
			p.c = p.ctab[i]
		end

		-- movement
		if p.to_x then
			p.x = p.x + ((p.to_x - p.x) / (4 / p.spd))
			p.y = p.y + ((p.to_y - p.y) / (4 / p.spd))
		end

		if p.sx then
			p.x = p.x + p.sx
			p.y = p.y + p.sy
			if p.to_x then
				p.to_x = p.to_x + p.sx
				p.to_y = p.to_y + p.sy
			end
			if p.drag then
				p.sx = p.sx * p.drag
				p.sy = p.sy * p.drag
			end
		end

		-- size
		if p.to_r then
			p.r = p.r((p.to_r - p.r) / (5 / p.spd))
		end

		if p.sr then
			p.r = p.r + p.sr
		end

		if p.age >= p.maxage or p.r < 0.5 then
			if p.onend == "return" then
				p.maxage = p.maxage + 32000
				p.to_x = p.ox
				p.to_y = p.oy
				p.to_r = nil
				p.sr = -0.3
			elseif p.onend == "fade" then
				p.maxage = p.maxage + 32000
				p.to_r = nil
				p.sr = -0.1 - rnd(0.3)
			else
				del(parts, p)
			end
			p.ctab = nil
			p.onend = nil
		end
	end
	-- 2 main ways to logic and animate
	-- sx/sy velocity system.  not great control if you want control over the particles final destination
	-- to_x/to_y destination definition
end

function grape(ex, ey, ewait, emaxage, espd, eonend, ectab, edrift)
	local spokes = 6
	local ang = rnd()
	local step = 1 / spokes
	local shakiness = rnd(3) - 1.5

	-- spawn spokes
	for i = 1, spokes do
		local myang = ang + step * i
		local dist = 8 + shakiness
		local dist2 = dist / 2
		local temp_ox = shakiness + ex + sin(myang) * dist2
		local temp_oy = shakiness + ey + cos(myang) * dist2

		add(parts, {
			draw = blob,
			x = temp_ox,
			y = temp_oy,
			ox = temp_ox,
			oy = temp_oy,
			r = 3,
			to_r = rndrange(3, 7),
			to_x = shakiness + ex + sin(myang) * dist,
			to_y = shakiness + ey + cos(myang) * dist,
			sx = 0,
			sy = edrift,
			spd = espd or 1,
			wait = ewait,
			maxage = emaxage,
			onend = eonend,
			c = ectab[1],
			ctab = ectab,
			ctabv = rnd(4),
		})
	end
	-- spawn center
	add(parts, {
		draw = blob,
		x = shakiness + ex,
		y = shakiness + ey - 2,
		r = 3,
		to_r = rndrange(6, 9),
		sx = 0,
		sy = edrift,
		spd = espd or 1,
		wait = ewait,
		maxage = emaxage,
		onend = eonend,
		c = ectab[1],
		ctab = ectab,
	})
end

:: prototypes/moveandshoot.lua
--[[pod_format="raw",created="2024-10-13 21:18:38",modified="2024-10-21 21:27:08",revision=487]]

:: prototypes/spark.lua
--[[pod_format="raw",created="2024-10-13 19:34:29",modified="2024-10-21 21:55:32",revision=192]]
function spark(p)
	-- pset(p.x, p.y, 8)
	line(p.x, p.y, p.x - p.sx * 2, p.y - p.sy * 2, 7)
	line(p.x + 1, p.y, p.x - p.sx * 2 + 1, p.y - p.sy * 2, p.c)
end

function sparkblast(ex, ey, ewait)
	local ang = rnd()
	for i = 1, 6 do
		local ang2 = ang + rnd(0.5)
		local spd = rndrange(4, 8)
		add(parts, {
			draw = spark,
			x = ex,
			y = ey,
			sx = sin(ang2) * spd,
			sy = cos(ang2) * spd,
			drag = 0.8,
			wait = ewait,
			maxage = rndrange(8, 20),
			c = 10,
			ctab = { 7, 10 },
		})
	end
end


:: prototypes/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTA5IDE3OjE2OjIzIixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDA5OjIxOjQxIixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiIscmV2aXNpb249MTkzMF1dbHo0AKUAAAAUCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzPyA9AAA8QQP--sPD-AQD-2B-L9gEHUP----_E
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDEwOjQ5OjA5Iixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiJdXQ==
:: draw.lua
--[[pod_format="raw",created="2024-10-21 21:26:28",modified="2025-02-02 06:49:46",revision=1349]]

function drw_game()
	cls(0)
	camera(-xscroll, 0)
	for seg in all(cursegs) do
		map(seg.x, seg.y, x_borders, scroll - seg.o, 21, 8)
	end

	for e in all(enemies) do
		if e.flash > 0 then
			e.flash = e.flash - 1
			flash_arr = { 8, 8, 8, 8, 8, 14, 7, 14, 15, 7, 7, 8, 8, 14, 7 }
			for i = 1, #flash_arr do
				pal(i, flash_arr[i])
			end
		end
		drawobj(e)
		debug_2 = myspr[cyc(e.age, e.ani, e.anis)]
		debug[2] = debug_2[1]
		pal()
	end
	
	for s in all(shots) do
		drawobj(s)
		if s.delme then
			del(shots,s)
		end
	end

	for p in all(parts) do
		if p.age and p.age >= 0 then
			-- animate color
			if p.ctab then
				p.ctabv = p.ctabv or 0
				local life = (p.age + p.ctabv) / p.maxage
				local i = mid(1, flr(1 + life * #p.ctab), #p.ctab)
				p.c = p.ctab[i]
			end
			p.draw(p)
		end
	end
	
	-- ship
	if inviz == 0 then
		if invul <= 0 or (time() * 15) % 1 < 0.5 then
			camera(0, 0) 
			
			if freeze > 0 then
				for i = 1,31 do
					pal(i,7)
				end
			end
			drawobj(pspr)
			
			local fframe = flr((t % (#anilib[1] - 1)) + 1)
		
			mspr(anilib[1][fframe], px - 2 + banked, py + 6)
			mspr(anilib[1][fframe], px + 3 - banked, py + 6, true)
			
			pal()
			camera(-xscroll, 0)
		end
	else
		inviz -= 1
	end

	
	-- enemy bullets last to favor visibility
	for b in all(buls) do
--		mspr(cyc(b.age, b.ani, b.anis), b.x, b.y)
		drawobj(b)
	end

	-- draw borders
	camera(0, 0)
	rectfill(0, 0, x_borders, 270, 32)
	rectfill(480, 0, 480 - x_borders, 270, 32)

	debug[1] = "scroll: " .. scroll
--	debug[2] = "fframe: " .. (t % (#anilib[1] - 1)) + 1
--	debug[3] = "enemies: " .. #enemies

--	mspr(27,40,135) -- DO NOT DIRECTLY CALL ANYMORE USE DRAWOBJ!! WILL CRASH OTHERWISE
end

function mspr(si, sx, sy, flip_x, flip_y)
	local ms = myspr[si]
	-- 1:i, 2:w, 3:h, 4:ox, 5:oy, 6:flip_x 7:flip_y
	sspr(gfx[ms[1]].bmp, 0, 0, ms[2], ms[3], sx - ms[4], sy - ms[5], ms[2], ms[3], ms.flip_x or flip_x, ms.flip_y or flip_y)
	if ms.nextspr then
		mspr(ms.nextspr, sx, sy)
	end
end

function msprc(si, sx, sy)
	local ms = myspr[si]
	-- 1:i, 2:w, 3:h, 4:ox, 5:oy, 6:flip_x 7:flip_y
	rect(sx - ms[4], sy - ms[5], sx - ms[4] + ms[2] - 1, sy - ms[5] + ms[3] - 1, rnd({8,14,15}))
end

function drw_menu()
	for seg in all(menucursegs) do
		map(seg.x, seg.y, x_borders - 20 + (sin(t % 300 / 300) * 20), scroll - seg.o, 21, 8)
	end
	rectfill(0, 0, x_borders, 270, 32)
	rectfill(480, 0, 480 - x_borders, 270, 32)
end

:: enlib.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEyLTE2IDA1OjUxOjQzIixtb2RpZmllZD0iMjAyNS0w
MS0yMyAyMTo1NjowNiIscmV2aXNpb249NV1dbHo0ACEAAAAfAAAA8BB7ezUsNiwxLDUwMCwyOX0s
ezcsMSwyLDk5OSwyOX19
:: explmain.lua
--[[pod_format="raw",created="2024-12-09 17:16:23",modified="2024-12-09 19:33:45",revision=127]]

:: gameplay.lua
--[[pod_format="raw",created="2024-10-21 21:26:48",modified="2025-02-02 06:49:46",revision=1273]]
--gameplay

function die()
	freeze = 6
end

function respawn()
	explode(px-xscroll, py)
	inviz = 30
	invul = 150
end

function spawnenemy(_i, _x, _y)
	-- play range for these enemies is 143-379 with current coordinate system
	local en = enlib[_i]
	
	add(enemies, {
		x = _x,
		y = _y,
		ani = anilib[en[1]],
		anis = en[2],
		sx = 0,
		sy = 0,
		brain = en[3],
		age = 0,
		flash = 0,
		hp = en[4],
		col = en[5],
	})
	
	--[[
	add(buls, {
		x = 280,
		y = 64,
		sx = 0,
		sy = 0,
		ani = anilib[6],
		anis = 4,
		age = 1,
	})
	]]--
	
end

function doenemies()
	for e in all(enemies) do
		if e.brain == 1 then
			if e.age < 12 then
				-- fly down
				e.sy = 2.3
			elseif e.age < 120 then
				if e.age == 60 then
					add(buls, {
						x = e.x,
						y = e.y,
						sx = 0,
						sy = 2,
						ani = anilib[6],
						anis = 4,
						age = 1,
						col = 21,
					})
				end
				-- stay
				e.sy = max(0, e.sy - 0.02)
			else
				-- fly up
				e.sy = e.sy - 0.04
				if e.y < -16 then
					del(enemies, e)
				end
			end
		end
		e.age = e.age + 1
		e.x = e.x + e.sx
		e.y = e.y + e.sy
	end
end

function doshots(arr)
	for s in all(arr) do
		s.age = s.age + 1
		s.x = s.x + s.sx
		s.y = s.y + s.sy

		if s.y < -16 or s.y > 280 then
			del(arr, s)
		end
	end
end

function shoot()
--	slowmo = true
	local shotspd = -12
	shotwait = 2
	add(shots, {
		x = px - 5 + banked - xscroll,
		y = py - 4,
		sx = 0,
		sy = shotspd,
		ani = anilib[3],
		anis = 2,
		age = t % 4 + 1,
		col = 30,
	})
	add(shots, {
		x = px + 5 - banked - xscroll,
		y = py - 4,
		sx = 0,
		sy = shotspd,
		ani = anilib[3],
		anis = 2,
		age = t % 4 + 1,
		col = 30,
	})
	add(parts,{
		draw = sprite,
		maxage = 4,
		x = -4 + banked,
		y = -1,
		ani = anilib[2],
		age = -1,
		plock = true,
	})
	add(parts,{
		draw = sprite,
		maxage = 4,
		x = 6 - banked,
		y = -1,
		ani = anilib[2],
		age = -1,
		plock = true,
	})
end

:: main.lua
--[[pod_format="raw",created="2024-09-22 09:21:41",modified="2025-02-02 06:49:46",revision=2551]]
---@diagnostic disable-next-line: undefined-global
include("tools.lua")
include("draw.lua")
include("update.lua")
include("gameplay.lua")
include("particles.lua")
include("profiler.lua")

function _init()
	profile("_init")
	t = 0
	debug = {}
	profile.enabled(true, true)

	myspr = fetch("/shmup/myspr.pod")
	anilib = fetch("/shmup/anilib.pod")
	enlib = fetch("/shmup/enlib.pod")
	sched = fetch("/shmup/sched.pod")
	mapsegs = fetch("/shmup/mapsegs.pod")
	
	gfx = fetch("/shmup/gfx/spr.gfx")
	
	sprval = 3

	butdic = { -- 0 - stop
		1, -- 1  - left
		2, -- 2  - right
		0, -- 3  - stop l+r
		3, -- 4  - up
		5, -- 5  - diag u+l
		6, -- 6  - diag u+r
		3, -- 7  - up u+l+r
		4, -- 8  - down
		8, -- 9  - diag d+l
		7, -- 10 - diag d+r
		4, -- 11 - down r+l+d
		0, -- 12 - stop u+d
		1, -- 13 - left l+u+d
		2, -- 14 - right r+u+d
		0, -- 15 - stop l+r+u+d
	}
	butdic[0] = 0
	dirx = { -1, 1, 0, 0, -0.75, 0.75, 0.75, -0.75 }
	diry = { 0, 0, -1, 1, -0.75, -0.75, 0.75, 0.75 }

	x_borders = 132
	-- 216px horizontal space mirrors 5:4 tate at 270:216
	-- on a 480px wide display, this would require two padding sections at 132px each

	menusegs = { 5 }
	menusegs[0] = 4
	menucursegs = {}
	scroll = 0
	mapsegi = 0
	xscroll = 0
	
	-- global hitstop
	freeze = 0

--	_upd = upd_menu -- starts on a little animated splash screen
--	_drw = drw_menu
	startgame()
	
	-- show hitboxes if true
	coldebug = false
end

function _draw()
	_drw()
	-- debug
	cursor(4, 4)
	color(7)
	for txt in all(debug) do
		print(txt)
	end
end

function _update()
	if slowmo then
		for i = 0,59 do
			flip()
		end
	end
--	debug[1] = #parts
--	debug[2] = tostr(myspr[1][1])
	
	if freeze > 0 then
		freeze -= 1
		if freeze == 0 then
			respawn()
		end
	else
--		if keyp("f") then
			t = t + 1
			_upd()
--		end
	end
end

function startgame()
	px, py = 240, 230
	spd = 1.537
	lastdir = 0
	shipspr = 0

	scroll = 14 --700 -- default 14
	xscroll = 0
	mapsegi = 1
	seglib = {}
	cursegs = {}

	boss = false

	parts = {}
	shots = {}
	shotwait = 0
	banked = 0
	enemies = {}
	buls = {}
	
	schedi = 1

	pcol = false
	
	pspr = {
		x = 0,
		y = 0,
		age = 0,
		ani = {3},
		col = 28,
	}
	
	invul = 0
	inviz = 0
	freeze = 0
	
	_upd = upd_game
	_drw = drw_game
	
--	debug[1] = "yes!"
end

:: particles.lua
--[[pod_format="raw",created="2024-10-21 21:26:56",modified="2025-02-02 06:49:46",revision=1155]]
function blob(p)
	local flr_r = flr(p.r)
	local _r = {
		0,
		flr_r * 0.05,
		flr_r * 0.15,
		flr_r * 0.30,
	}

	--	local pat = { -- we can also use dither_mask(value) values instead
	--		0b0000000000000000,
	--		0b0001101001011010,
	--		0b0111111111111111,
	--		0b1111111111111111
	--	}

	local pat = {
		dither_mask(1),
		dither_mask(9 / 16),
		dither_mask(1 / 16),
		dither_mask(0),
	}

	if flr_r <= 5 then
		deli(_r, 4)
		deli(_r, 2)
		deli(pat, 2)
		deli(pat, 2)
	--	elseif flr_r <= 6 then
	--		deli(_r,3)
	--		deli(pat,3)
	elseif flr_r <= 8 then
		deli(_r, 4)
		deli(pat, 3)
		pat[2] = 0b1001001001001001
	elseif flr_r >= 12 then
		--		deli(_r,4)
		--		deli(pat,3)
		--		pat[2]=0b1001001001001001
		_r[2] = flr_r * 0.02
		_r[3] = flr_r * 0.08
		_r[4] = flr_r * 0.12
	end
	--	fillp(dither_mask(3/8))
	--	fillp(0b0001101001011010)
	--	circfill(p.x-2,p.y+2, flr_r, 0x1814) -- adds dark outline
	--	circfill(p.x-1,p.y+1, flr_r, 21) -- adds dark outline
	for i = 1, #_r do
		--		poke(0x550b,0x3f) -- set black to transparent
		--		palt()            -- recommended but what is this doing?
		--		fillp(dither_mask(i/#_r))
		fillp(pat[i])
		circfill(p.x, p.y - _r[i], flr_r - _r[i], p.c)
		--		poke(0x550b,0x00) -- set back to black
	end

	fillp()
	if flr_r == 1 then
		pset(p.x, p.y, p.c)
	elseif flr_r == 2 then
		rectfill(p.x - 1, p.y - 1, p.x + 1, p.y + 1, p.c)
	end
end

function explode(ex, ey)
	add(parts, {
		draw = blob,
		x = ex,
		y = ey,
		r = 17,
		maxage = 2,
		ctab = { 0x0707, 0x070a },
	})

	sparkblast(ex, ey, 2)
	sparkblast(ex, ey, 15)

	grape(ex, ey, 2, 13, 1, "return", { 0x070a, 0x070a, 0x070a, 0x0a09 }, 0)
	grape(ex + rnd(5) - 2.5, ey - 5, 10, 20, 1, "return", { 0x070a, 0x0a09, 0x090a }, -0.2)
	grape(ex + rnd(5) - 2.5, ey - 10, 25, 25, 0.2, "fade", { 0x070a, 0x070a, 0x0a09, 0x090a, 0x0d08, 0x0d05 }, -0.3)
end

function dopart(p)
	-- age and wait
	p.age = p.age or 0

	if p.age == 0 then
		p.ox = p.x
		p.oy = p.y
		p.r = p.r or 1
		p.ctabv = p.ctabv or 0
		p.spd = p.spd or 1
	end
	p.age = p.age + 1

	if p.age <= 0 then
		return
	end

	-- movement
	if p.to_x then
		p.x = p.x + ((p.to_x - p.x) / (4 / p.spd))
		p.y = p.y + ((p.to_y - p.y) / (4 / p.spd))
	end

	if p.sx then
		p.x = p.x + p.sx
		p.y = p.y + p.sy
		if p.to_x then
			p.to_x = p.to_x + p.sx
			p.to_y = p.to_y + p.sy
		end
		if p.drag then
			p.sx = p.sx * p.drag
			p.sy = p.sy * p.drag
		end
	end

	-- size
	if p.to_r then
		p.r = p.r + ((p.to_r - p.r) / (5 / p.spd))
	end

	if p.sr then
		p.r = p.r + p.sr
	end

	if p.age >= p.maxage or p.r < 0.5 then
		if p.onend == "return" then
			p.to_x = p.ox
			p.to_y = p.oy
			p.to_r = nil
			p.sr = -0.3
		elseif p.onend == "fade" then
			p.to_r = nil
			p.sr = -0.1 - rnd(0.3)
		else
			del(parts, p)
		end
		p.ctab = nil
		p.onend = nil
		p.maxage = 32000
	end
	-- 2 main ways to logic and animate
	-- sx/sy velocity system.  not great control if you want control over the particles final destination
	-- to_x/to_y destination definition
end

function grape(ex, ey, ewait, emaxage, espd, eonend, ectab, edrift)
	local spokes = 6
	local ang = rnd()
	local step = 1 / spokes
	local shakiness = rnd(3) - 1.5

	-- spawn spokes
	for i = 1, spokes do
		local myang = ang + step * i
		local dist = 8 + shakiness
		local dist2 = dist / 2
		local temp_ox = shakiness + ex + sin(myang) * dist2
		local temp_oy = shakiness + ey + cos(myang) * dist2

		add(parts, {
			draw = blob,
			x = temp_ox,
			y = temp_oy,
			ox = temp_ox,
			oy = temp_oy,
			r = 3,
			to_r = rndrange(3, 7),
			to_x = shakiness + ex + sin(myang) * dist,
			to_y = shakiness + ey + cos(myang) * dist,
			sx = 0,
			sy = edrift,
			spd = espd or 1,
			age = -ewait,
			maxage = emaxage,
			onend = eonend,
			ctab = ectab,
			ctabv = rnd(4),
		})
	end
	-- spawn center
	add(parts, {
		draw = blob,
		x = shakiness + ex,
		y = shakiness + ey - 2,
		r = 3,
		to_r = rndrange(6, 9),
		sx = 0,
		sy = edrift,
		spd = espd or 1,
		age = -ewait,
		maxage = emaxage,
		onend = eonend,
		ctab = ectab,
	})
end

function spark(p)
	-- pset(p.x, p.y, 8)
	line(p.x, p.y, p.x - p.sx * 2, p.y - p.sy * 2, 7)
	line(p.x + 1, p.y, p.x + p.sx * 2 + 1, p.y + p.sy * 2, p.c)
end

function sparkblast(ex, ey, ewait)
	local ang = rnd()
	for i = 1, 6 do
		local ang2 = ang + rnd(0.5)
		local spd = rndrange(4, 8)
		add(parts, {
			draw = spark,
			x = ex,
			y = ey,
			sx = sin(ang2) * spd,
			sy = cos(ang2) * spd,
			drag = 0.8,
			age = -ewait,
			maxage = rndrange(8, 20),
			ctab = { 7, 10 },
		})
	end
end

function sprite(p)
	local _x,_y = p.x, p.y
	if p.plock then
		_x += px - xscroll
		_y += py
	end
	mspr(cyc(p.age,p.ani,p.anis), _x, _y)
end
:: profiler.lua
--[[pod_format="raw",created="2024-09-20 18:19:15",modified="2025-02-02 06:49:46",revision=1063]]
-- abledbody's profiler v1.1

local function do_nothing() end

-- The metatable here is to make profile() possible.
-- Why use a table at all? Because otherwise lua will try to cache the function call,
-- which by default is do_nothing.
local profile_meta = { __call = do_nothing }
profile = { draw = do_nothing }
setmetatable(profile, profile_meta)

local running = {} -- All incomplete profiles
-- All complete profiles. Note that if the profiles haven't been drawn yet, it will
-- not be cleared, and further profiles of the same name will add to the usage metric.
local profiles = {}
-- All completed lingering profiles. These are never automatically cleared.
local lingers = {}

-- start_profile, stop_profile, and stop_linger are all internal functions,
-- serving as paths for _profile to take. Lingers share start_profile.
local function start_profile(name, linger)
	local source = profiles[name]
	running[name] = {
		linger = linger,
	}
	local active = running[name]
	active.start = stat(1) --Delaying CPU usage grab until the last possible second.
end

local function stop_profile(name, active, delta)
	local profile = profiles[name]
	if profile then
		profile.time = delta + profile.time
	else
		profiles[name] = {
			time = delta,
			name = name,
		}
		add(profiles, profiles[name])
	end
end

local function stop_linger(name, active, delta)
	local profile = lingers[name]
	if profile then
		profile.time = profile.this_frame and delta + profile.time or delta
		profile.this_frame = true
	else
		lingers[name] = {
			time = delta,
			this_frame = true,
		}
	end
end

-- The main functionality lives here.
-- Takes in the name of what you're profiling, and whether or not to
-- make the profile linger.
local function _profile(_, name, linger)
	local t = stat(1)
	local active = running[name]
	if active then
		local delta = t - active.start

		if active.linger then
			stop_linger(name, active, delta)
		else
			stop_profile(name, active, delta)
		end

		running[name] = nil
	else
		start_profile(name, linger)
	end
end

-- Clears all lingering profiles.
function profile.clear_lingers()
	lingers = {}
end

local function draw_cpu()
	print("cpu:" .. string.sub(stat(1) * 100, 1, 5) .. "%", 1, 1, 7)
end

-- This draws the profiles, and then resets everything for the next frame.
-- If it is not called, usage metrics will accumulate.
-- Lingering profiles are always displayed after persistent profiles.
local function display_profiles()
	local i = 1
	for prof in all(profiles) do
		local usage = string.sub(prof.time * 100, 1, 5) .. "%"
		local to_print = prof.name .. ":" .. usage
		print(to_print, 1, 1 + i * 9, 7)
		i = i + 1
	end
	for name, prof in pairs(lingers) do
		local usage = string.sub(prof.time * 100, 1, 5) .. "%"
		local to_print = name .. (prof.this_frame and "[X]:" or "[ ]:") .. usage
		print(to_print, 1, 1 + i * 9, 7)
		prof.this_frame = false
		i = i + 1
	end
	profiles = {}
end

local function display_both()
	draw_cpu()
	display_profiles()
end

-- This swaps out function calls depending on whether or not you want to have
-- profiling. This is to make it as much as possible so that you don't have to
-- think about cleaning up profile calls for efficiency.
-- The first boolean is for detailed profiling, the second is for CPU usage.
function profile.enabled(detailed, cpu)
	profile_meta.__call = detailed and _profile or do_nothing
	profile.draw = detailed and (cpu and display_both or display_profiles) or (cpu and draw_cpu or do_nothing)
end


:: tools.lua
--[[pod_format="raw",created="2024-10-21 21:26:41",modified="2025-02-02 06:49:46",revision=1178]]
-- alternate to sgn, different in that 0 returns 0 instead of 1
function mysgn(v)
	return v == 0 and 0 or sgn(v)
end

-- for a value x between range in_min and in_max, map the value at the same
-- relational position between out_min and out_max
function map_range(x, in_min, in_max, out_min, out_max)
	return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min)
end

-- returns a random value inclusively between low and high
function rndrange(low, high)
	return flr(rnd(high + 1 - low) + low)
end

-- dither mask suite
local threshold_map = {
	0,
	8,
	2,
	10,
	12,
	4,
	14,
	6,
	3,
	11,
	1,
	9,
	15,
	7,
	13,
	5,
}

local function make_mask(value)
	local mask = 0
	for i = 1, 16 do
		mask = mask * 2
		if threshold_map[i] >= value then
			mask = mask + 1
		end
	end
	return mask
end

local dither_masks = {}

for i = 0, 16 do
	dither_masks[i] = make_mask(i)
end

-- value 0-1
function dither_mask(value)
	return dither_masks[mid(0, flr(value * 16 + 0.5), 16)]
end

function col(x1, y1, w1, h1, x2, y2, w2, h2)
	local a_left = x1
	local a_top = y1
	local a_right = x1 + w1 - 1
	local a_bottom = y1 + h1 - 1

	local b_left = x2
	local b_top = y2
	local b_right = x2 + w2 - 1
	local b_bottom = y2 + h2 - 1

	if a_top > b_bottom then
		return false
	end
	if b_top > a_bottom then
		return false
	end
	if a_left > b_right then
		return false
	end
	if b_left > a_right then
		return false
	end

	return true
end

function col2(oa, ob, xscr)
	-- 1:i, 2:w, 3:h, 4:ox, 5:oy, 6:flip_x 7:flip_y
	local msa = myspr[oa.col]
	local msb = myspr[ob.col]
	
	local a_left = oa.x - msa[4] - (xscr and xscroll or 0)
	local a_top = oa.y - msa[5]
	local a_right = a_left + msa[2] - 1
	local a_bottom = a_top + msa[3] - 1

	local b_left = ob.x - msb[4]
	local b_top = ob.y - msb[5]
	local b_right = b_left + msb[2] - 1
	local b_bottom = b_top + msb[3] - 1

	if xscr then
		
	end
	
	if a_top > b_bottom then
		return false
	end
	if b_top > a_bottom then
		return false
	end
	if a_left > b_right then
		return false
	end
	if b_left > a_right then
		return false
	end

	return true
end

function cyc(age, arr, anis)
	anis = anis or 1
	return arr[(age\anis) % #arr + 1]
end

function drawobj(obj)
	mspr(cyc(obj.age, obj.ani, obj.anis), obj.x, obj.y)
	if coldebug and obj.col then
		msprc(obj.col, obj.x, obj.y)
	end
end
:: update.lua
--[[pod_format="raw",created="2024-10-21 21:26:35",modified="2025-02-02 06:49:46",revision=1281]]
function upd_game()
	-- SCROLLING
	scroll = scroll + 0.5

	if #cursegs < 1 or scroll - cursegs[#cursegs].o > 0 then
		if boss then
			scroll = scroll - 128
			for seg in all(cursegs) do
				seg.o = seg.o - 128
			end
		else
			mapsegi = mapsegi + 1
		end

		local segnum = mapsegs[mapsegi] or 0

		add(cursegs, {
			x = 0,
			y = 248 - ((segnum - 1) * 8),
			o = #cursegs < 1 and -128 or cursegs[#cursegs].o + 128,
		})

		if #cursegs > 2 and scroll - cursegs[1].o >= 384 then
			deli(cursegs, 1)
		end
	end

	-- SPAWNING
	
	if sched[schedi] and sched[schedi][1] < scroll then
		spawnenemy(sched[schedi][2], sched[schedi][3], sched[schedi][4])
		schedi += 1
	end	

	-- INPUTS / MOVEMENT
	local dir = butdic[btn() & 0b1111]

	if lastdir ~= dir and dir >= 5 then
		px = flr(px) -- or flr(px) + 0.5
		py = flr(py) -- or flr(py) + 0.5
	end

	local dshipspr = 0
	banked = 0

	if dir > 0 then
		px = px + dirx[dir] * spd
		py = py + diry[dir] * spd

		dshipspr = mysgn(dirx[dir])
		banked = 1
	end

	shipspr = shipspr + mysgn(dshipspr - shipspr) * 0.18
	shipspr = mid(-1, shipspr, 1)

	lastdir = dir
	
	pspr.x = px
	pspr.y = py
	pspr.ani[1] = flr(shipspr * 2.4 + 3.5)

	-- boundary checking
	if px < x_borders then
		px = x_borders
	end
	if px > 480 - x_borders - 15 then
		px = 480 - x_borders - 15 -- 15 is sprite size with an offset
	end

	percentage_scrolled = mid(6 / 32, (px - x_borders) / 201, 26 / 32)
	xscroll = flr(map_range(percentage_scrolled * -32, -26, -6, -40, 0))

	-- shooting
	if shotwait > 0 then
		shotwait = shotwait - 1
	else
		if btn(4) then
			shoot()
		end
	end

	-- dokaaaaaaaaaan!!!
	if btnp(5) then
		explode(240, 135)
	end

	boss = btn(5)

	doshots(shots)
	doshots(buls)
	doenemies()

	-- colission
	pcol = false
	-- shots vs enemies
	for e in all(enemies) do
		for s in all(shots) do
			if not s.delme and col2(e,s) then
				e.flash = 2
				s.delme = true
				add(parts, {
					draw = sprite,
					x = s.x,
					y = s.y,
					age = -2,
					ani = anilib[4],
					maxage = 4,
				})
				e.hp = e.hp - 1

				if e.hp <= 0 then
					explode(e.x, e.y)
					del(enemies, e)
				end
			end
		end
	end

	-- ship vs enemies
	if invul <= 0 then
		for e in all(enemies) do
			if col2(pspr, e, true) then 
				die()
			end
		end
	
		-- ship vs bullets
		for b in all(buls) do
			if col2(pspr, b, true) then
				die()
			end
		end	
	else
		invul -= 1
	end

	for p in all(parts) do
		dopart(p)
	end
end

function upd_menu()
	-- SCROLLING
	scroll = scroll + 1

	if #menucursegs < 1 or scroll - menucursegs[#menucursegs].o > 0 then
		mapsegi = mapsegi + 1

		local segnum = menusegs[mapsegi % 2]

		add(menucursegs, {
			x = 0,
			y = 248 - ((segnum - 1) * 8),
			o = #menucursegs < 1 and -128 or menucursegs[#menucursegs].o + 128,
		})

		if scroll - menucursegs[1].o >= 384 then
			deli(menucursegs, 1)
		end
	end

	-- INPUTS
	if btnp(5) or btnp(4) then
		startgame()
	end
end

:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDA5OjIyOjM5Iixtb2RpZmllZD0iMjAyNS0w
Mi0wMiAwNjo0OTo0NiIscnVudGltZT0xMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzEwOSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZHJhdy5sdWEjODkiLHdvcmtzcGFj
ZV9pbmRleD0xfSx7bG9jYXRpb249InVwZGF0ZS5sdWEjNSIsd29ya3NwYWNlX2luZGV4PTF9LHts
b2NhdGlvbj0idG9vbHMubHVhIzEyNyIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0iZ2Ft
ZXBsYXkubHVhIzIwIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJwYXJ0aWNsZXMubHVh
IzQyIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJwcm9maWxlci5sdWEjNjUiLHdvcmtz
cGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdmeC8wLmdmeCIsd29ya3NwYWNlX2luZGV4PTJ9LHts
b2NhdGlvbj0ibWFwLzAubWFwIix3b3Jrc3BhY2VfaW5kZXg9M30se2xvY2F0aW9uPSJzZngvMC5z
ZngiLHdvcmtzcGFjZV9pbmRleD00fX1dXQ==
:: [eoc]
