picotron cartridge // www.picotron.net
version 2

:: gfx/
:: gfx/0.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTEzIDIxOjI5OjAxIixtb2RpZmllZD0iMjAyNC0x
MC0yMyAyMDozNjowOSIscmV2aXNpb249NjM2XV1sejQAZQwAAAg-AADzIXtbMF09e2JtcD1weHUA
QyAQEATwVgcQB8AX0BfABxAH8FYsZmxhZ3M9MCxwYW5feAgA2nk9MCx6b29tPTEyfSw-AE-yAe0C
AgAID08AHX-9AdYdBr0FBAAbP8X9AWgAHSkCDQIAXv0BAv0PAwAPVgAdMQoQGgIABAgAKxoACAAf
ECIAUw_4AB0v8PAyAIHwDWARwAEHBgGwIQ0BkAEsEYABDBccEXABDAcMAQwIAEAhDCFgBgDwGQEH
AVARHAEHEQYBUAENAQwHEQ0GDQEwAS0hDQYNBw0BIAEdBi0GDRYKAP8PDQYHFgcGDQYdATABBwYN
AQYHDSFQAQURFQ0RcGEwogAhLwYHogAEIGARogAiUBGiAJBAAQYBHBEHAQYKAGANAQwXEQaQAPQE
PTEdBgcBEAEdFj0GDRYBEAENFqEA-wIgEQcdEQcxQAEGFQEVDRFgcZ8AIoAWAaBRkAE8AZwAICwB
nADwARwBDAFQIQwxDCEwAQcBDDGeAGAwAQYRBxFCAQAjATENERdDARAAIwH2BAYNMQ0GDQYHESYN
Bj0GDSYRHQZFAf8DADEHARYBBzEwAQYBBREFAQYBpwAk8QQHBgGgAQ0hoBEsAYARDBccAXARRgGA
AWAhDCEMEVCqAAEIAPACBgEHERwBBgEwAQ0GERcMAQ2zAOAHBh0xPQEQARYNBj0WHU8BAqQAAPMB
zzEHER0HEUARDRUBFZ8AJi8GB58ACSIBYJ8AIAFgRwFBARwRQEUBMAcMAYcCcA0HDQYNIS1aAUAW
DQYt2gEVAUQBYAEwIQ0HBpcCvwFQEQ0VEQUBcGFAjQOBDzIAHP8FBAYEAB8YAA4XHhceHxceHQ4A
HgBBABp-CAgEIAfwLDQAH49QBwwHUAfwHDoAIL8nQAcMB0AX0AfwBT4AJgNCAD9gB0BDACIFRQB-
UAdgB1AHQNkBfvIQCBAEIBlQGUAJFwkwCRcJIAk3CRAJNwkACQcKFwoHGQYAMRoXGgQA-wYKCRoJ
CjkaWRo5ADkAGRAZEAkgGSBvACEAcQA1GgkwdQBYChcKCRAGADEZGhkEABFZAgBvCQAZAAkwawAl
DG8AMjAJGgQAEjkCAF9AGVAZIGcBHv8HNxewV4B3cHdgl1CXUJdgd4BXoDfwFkcACxw4RgDxBGAX
0BfQF6AHEBcQB2AXADcAF1AGAP8AYHdQBwB3AAcwt0CXYHdwXQAjYPAEB1AHcD0D-xMLF9AXcAdA
F0AHIAcgNyAHYFeQV2AHEFcQB2BXoDfAF-AXWwAcEDBWAGE0B9AH8CFXAF9wF8A3sEkAIS-w8DEA
-6W3-xAGMb4xnhE_EX4EAGKeUZ5R3hECAG_eMb4x-gZXADIPBAAFD2MAIi-w8OAB-xSqBxHeEb4x
vjHeEQIAb75RnlH_BdgBKgFHAAcEAG-ecX5x-gRTADJv-gAR3hF_IAIpf-8QBBEeEZ4EAAExcX5x
rwADAgAPWwAhQ3F_cX4-ABDeSQETAA0AEH4NAB8GAwEkBlAABA8BDwIBLTNxfnFVACMRvgQABAIA
L-4IqQEqCJoAD64AMsrwRg0PFR2wHh2wDQ4EAE8uDfA2TQAf4R8VDbAOHQ6wLQ6wHQ4NSQBPDi2w
PksAMCEtDg4ALw0emAAhdQ8VDQ4NsA4FABE_UwADBAAPUAAgID8V1wBBDi2wLpkALy0OLwEpBEkA
Lw4d4wApST8VsC14AQMEAA_XACYGjgAPmgArH-AxAP---------------zRfCAgE8DBiAB4PjQX-
-----0wxfAEMAgAv-CE5ABwj-CE6AB98OQAc7yEsUSxRPEE8QTxRLFEsdwAdk2sBK0ErAQYdAQUA
nzYrAQ0RDTsxe0gAHKERWwYxKwYRFgEbBQCvRgEbHRENARtBq0gAHFH7CQkKGwMANCkKGwsAPyMK
i0cAHEuBRwYRAwA-B0YBRQAc0R01LQU2BR0FBhUGBR0KACAHLAUAYh0VHQUHFgUAHw1UACAhBi1V
ABANBgAULVYAbzYFHVUtRU8AHSILaQIAIhtZAgAPPwAcAzYAExtGAB8LPwAc-wHxBAYdQQYdQTYx
DRANMTBxPwAccHEGYQYRFiEEAI9GIR0QDSFAoUIAHO_RVxFXEVYRVhENEC0hQIAAHXEBBk0RBzYN
BAD-Al0RXBENBRYFDREADRUNABFQLQIdEw0YAggdAhYdFAA-ZR1VUQAcQAuTCwMCAC-7HzkAHGBT
GwMrMzs6AB8ZOgAcL-kwMQAcsrs0GxQ5GwRJCwRZQgIPQAAdP3T5HDMAHL97NDs5FBtJBBtZBLUC
I8C9BQ0VLQUBBREdBQECAN8dEQUhDRVBDQEFQQ1hTAAdqRUNJQ0FEQUhBQECAC-xB0kAHJF9FQ0F
PREFAQWaABAFlADPBQ0xBQEdMQUBBQ1hFwQd8QMFDRUNFR0VDQUNBgUdFQ0GJR31AP8CDRUGFR0G
BQYFDQUNNT0FLQVYAB0v_DCgBCgvOzlVBh0-_SS7MgAcA28AEAvVBC85u8MDHjBRDWECAK8dBUEd
UT0BBRF9QgAcf-EeBREFEb02ABwwYQ1R5AG-QQUdUR0hBQ0BHQFEAB8v_DAxAE0f_zEAHmMKAwsD
KwPGBB8JPgAcxQNhCwNBBwNRBwsDUQoAEUEEAA9KABybQQMbUQMLQQMbCQAPRwAc-wj7AUEbAQcR
FwELAQcBFyEDYQMBEwEDEdQCHf8OiyFLAQcROwEHISsRBwEHARsBAwEHESsDQSsBCxGUAB0SK2IB
8QBzNQMlFAUEBQQFJAWkAgQCAB90SwAc-wsLA0sjSwMFEwsDCxMEBUMFFEUCFFIkQjQiBEkAHGAb
AxsDCyMcAV-xGTcBF0gHHXDxGRMBEwETRgAP9QkdgPEHA1ETUQMLfAAwAQMLiABPARNLAeoBHsDx
AANhE1ELA1ETERNIAI8BAwsTGwMBS0cAHPEA_wJBGwEXEQcxFwEHcQMRLwIPLgIdgLshOxEHASsh
KAL-AwcBBxEbEQcBAwELQQMrEQMBK00AHAMaAhIUCAAfEg4ACCKSBAgAD2EAIxA0BgD-BjIWBQIE
EgYlMjUCBCIVIgRCBAIEUlEAHTILUwvIAYATWwN7A1sDCwQAAKMCEDOnAg9NAByQ6wFbAQNLAQNb
AwAhE0sGAA9DABxAewFrAwMAcUsTAVsDAVsJAA8XAh1QcwFTEQOhAjARA1FdArEUAQMbAwESATMB
EgoAHxOxAh8vg1sgATH-BPsAA1sjOxMLAzsDGwM7QysDG1OJAB1v8ghxfHF8iAsd8AYiFDJEIhRC
AQRCAQwBMgEMAVwBDFEGAA9aASsREbkDAA4AERt_AxELGgAP0wAd-wNLARNbAQNrAVsDAlsDAmsD
_wBBABz-AhMBSwMBWwFrAgNbAgNbA-sHQAAe-wYTASMBMwEDAVMBAlMSUwITOyNbA3scASa-BFEE
IhQiEzJDEiNFACkwAyIUXwGvIgEDCyMSARMLM7cCHwDcAxE7qgJvJTMFJDVEvAYm8AIhIjECBBIR
DAIEMhxSDAEMMkgREDxOEV8xDCE8EUcCKBAEoQNAIhMBIj4CbxIjCwMBM_YAHR-8OAkdb-wKJwwH
-LYAHX-8EQcMJ-wKNgAc8AxrBVsFDEsFBw07BQ0GDSsVDQYNGwUtBg0LBR0RABEFAgAfBicMHU91
fP0gMwAcgAVrDQVbHQVLcQBgOw0VDQUrWg2vGw01DQULDUUNBU8AHBLxiA0jARUIAD-1APO4Ax1v
8xALUxvTBAUhbwMSIxLzEDcAHP8C_wsFKwUtBS0FKwUrBSMFIwWdAx0v8TAlDh4jBQ3lAVMtBg0F
LQwADxQACg8LAh4f-ZYAHSoNZQIADz8AHG_NFQ0F-SN8ASEAfgHfKw0DGwUrDSMFKwUDK0UAH687
LQVrDTsjDQNbPwAg8AAHASsFGwEDLQUNAQM7BQtYBS8FA8AKIz8hV4EMAh_CLQcMBS0FBiU1ECAF
DScQEBYMACANJgsAfzYVDUYFDVZYABxffHV99hg0ABz-BAflHVUWDUUmDTU2DSVGDRVWDQV2AB9w
Jh1GDRYNNgQALz2WPwAcUSsFA1sNAwA6BQMbGAIfe0sAKCErLQ0ATysjDQMWFx4QAHYKAKYCIAsD
JBIjEwELAD8jBQuZDB9EKwUTS5UAF1sMAA_zAh05CwVWAwBfZQtjC2NEABw-9hh1mgUeOFYFCwMA
AXcADyQDHSOWPRwCD38ADFBtPTh9fQ==
:: gfx/ship.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTEzIDIxOjI1OjE4Iixtb2RpZmllZD0iMjAyNC0x
MC0xMyAyMToyNToxOCIscmV2aXNpb249MF1dbHo0AAcEAACpNgAA8yF7WzBdPXtibXA9cHh1AEMg
EBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIANp5PTAsem9vbT0xMn0sPwBP8gHtAgIA
CA9PAB1--QHWHQa9BQQAGz-F-QFoAB0pAg0CAF79AQL9DwMAD1YAHTEKEBoCAAQIACsaAAgAHxAi
AFMPuAAdL-DwMgCB8A1gEcABBwYBsCENAZABLBGAAQwXHBFwAQwHDAEMCABAIQwhYAYA8BkBBwFQ
ERwBBxEGAVABDQEMBxENBg0BMAEtIQ0GDQcNASABHQYtBg0WCgD-Dw0GBxYHBg0GHQEwAQcGDQEG
Bw0hUAEFERUNEXBhMKIAIS8GB6IABCBgEaIAIlARogCQQAEGARwRBwEGCgBgDQEMFxEGkAD0BD0x
HQYHARABHRY9Bg0WARABDRahAP8CIBEHHREHMUABBhUBFQ0RYHGfACKAFgGgUZABPAGcACAsAZwA
8AEcAQwBUCEMMQwhMAEHAQwxngBgMAEGEQcRQgEAIwExDREXQwEQACMB9gQGDTENBg0GBxEmDQY9
Bg0mER0GRQH-AwAxBwEWAQcxMAEGAQURBQEGAacAJPEEBwYBoAENIaARLAGAEQwXHAFwEUYBgAFg
IQwhDBFQqgABCADwAgYBBxEcAQYBMAENBhEXDAENswDgBwYdMT0BEAEWDQY9Fh1PAQKkAADzAc8x
BxEdBxFAEQ0VARWfACYvBgefAAkiAWCfACABYEcBQQEcEUBFATAHDAGHAnANBw0GDSEtWgFAFg0G
LdoBFQFEAWABMCENBwaXAr8BUBENFREFAXBhQI0DgQ8yABz-BQQGBAAfGAAOFx4XHh8XHh0OAB4A
QQAafwgIBCAH8Cw0AB_PUAcMB1AH8Bw6ACC-J0AHDAdAF9AH8AU_ACYDQgA-YAdAQwAiBUUAf1AH
YAdQB0DZAX7yEAgQBCAZUBlACRcJMAkXCSAJNwkQCTcJAAkHChcKBxkGADEaFxoEAP8GCgkaCQo5
GlkaOQA5ABkQGRAJIBkgbwAhAHEANRoJMHUAWAoXCgkQBgAxGRoZBAARWQIAbwkAGQAJMGsAJQxv
ADIwCRoEABI5AgBfQBlQGSBnAR7-BzcXsFeAd3B3YJdQl1CXYHeAV6A38BZHAB3xBGAX0BfQF6AH
EBcQB2AXADcAF1AGAP8AYHdQBwB3AAcwt0CXYHdwXgAkYPAEB1AHcD8D-xMLF9AXcAdAF0AHIAcg
NyAHYFeQV2AHEFcQB2BXoDfAF-AXXAAdEDBXAGE0B9AH8CFYAF9wF8A3sEoAIi-w8DIA--------
--------------------------------------------------VQPTEyfX0=
:: gfx/stage.gfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTEwLTEzIDIxOjI2OjIzIixtb2RpZmllZD0iMjAyNC0x
MC0xMyAyMToyNjoyMyIscmV2aXNpb249MF1dbHo0AP8BAABtNAAA8yF7WzBdPXtibXA9cHh1AEMg
EBAE8FYHEAfAF9AXwAcQB-BWLGZsYWdzPTAscGFuX3gIAMp5PTAsem9vbT04fSw_AE-yAe0CAgAI
D04AHH-9AdYdBr0FBAAbP8X9AWcAHCkCDQIAXv0BAv0PAwAPVQAcMQoQGgIABAgAKxoACAAfECIA
Uw_3ABwv8PAxAP-------6TH8gBdPxW9Pp0ePR59BABinV6dXt0eAgBvnT69Pv0GWAAzDwQABQ9k
ACIv8PDiAf8Uum0fFd0evT69Pt0eAgBvvV6dXv0F2gErAUgABwQAb91_fX79BFQAM2-9AB7dHn0j
Aimf8gA9HxUdHp0eBAAAMX59frEAAwIAD1wAIVN-FX1_fUAAEN1NARMADQAQfQ0AHwYGASUGUQAE
EgEPBQEtAKkAA1YAIx69BAAEAgAv-QiuASsInAAPsAAyyvBGDQ8VHbAeHbANDgQATy4N8DZNAB-h
HxUNsA4dDrAtDrAdDg1JAE8OLbA_SwAwIS0ODgAvDR6YACF1DxUNDg2wDgUAET5TAAMEAA9QACAg
PxXXAEEOLbAumQAvLQ4vASkESQAvDh3jAClJPxWwLXgBAwQAD5cAJgaOAA_aACsf8DEA--------
----------------------------------------vFBtPTh9fQ==
:: gfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDEwOjQ5OjA5Iixtb2RpZmllZD0iMjAyNC0x
MC0yMyAyMDozNjowOSJdXQ==
:: map/
:: map/0.map
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDA5OjIxOjQxIixtb2RpZmllZD0iMjAyNC0x
MC0yMyAyMDozNjowOSIscmV2aXNpb249MTEwN11dbHo0AIkMAABpQAAA-xZ7e2JtcD11c2VyZGF0
YSgiaTE2IiwxNiwyNTYsIjAwOWYwMDAzBAAjIzlmQAAfMQQAIQ9AAPtXMzIwMDMcAA_AAFofMwQA
IwVAAB8xBAAhDwAC-wESMAwAD4AAXh8zBAAjBUAAHzEEACEPAAL-ACIyOQwAD4AAXh8zBAAjBUAA
HzEEACEPAAL8UjEwMDI4DAAPgABZ42QwMDBkODAwZDQwMGQzCAAMEAAIGAAIMAAACAASZAwAEGUY
ABNiEAAXMBAAF2MYAARMABcwVAATOSQAW2EwMGMxEAATMAQACBgAGmIIAC9jOAQALFI5MDBjYZQA
I2NiEAAeORgADygABSdkNQwBFzQQAA4YAA8QAAMIFAAPCAAhCAwADwgAICNlMQQAFzMMAAQEAB4y
DAAPBAAaD1QAAQtMAG9hZDAwYWUIABAPFAABF2QkAgBUAhMx3AAWMhQADwQAFSdkMcgCCHwCD0AA
FQSgAg88ABwvZWEEACsESAAQYgQAD-gAIABEABBmiAGHNjAwYTcwMGYUAA8MABFnYzQwMGZiQAAA
HAMSYwgAAQwAFzUMAAMsAAgkAC9jNUAAABJkCAANTAAeZFgAAYgAFzlAABY4FAAPDAARBMgABUAA
DugADwABCwOUAAVAAAzoAB81zAALL2NjQAAAHjUoAA1YAB80AAEzBDwCImFmBAAuYjFIAhBlGAMX
NQQAHjYcAA8EAArAYzAwYjMwMGI0MDBiEAAWZUgAABwAEGXQAxI1BAArZWQEABNmQABAYjAwYggA
E2RAABNmCAADQAAFLAADCAArYjZAABM2DAAfZkAAAwQgAAWoAAOsACtiNiQAE2Q4ABpkQAAiYTU8
ACplYgQAI2I1JAATZjQABHgAH2ZAAAAHOAAFQAAfZEAABBpkQAAEoAAFKAEELAEbZkAAH2RAAAAI
HAAXZuwABBgAGmMcAA1AAAPAACZhNQwAD0AAAS9hNUAAEydlZgwAB0AAL2VkQAAHDgQAD4AAGwUs
AAwMAA9AABQmYTUgAAgMAAhAAAVcAA9AABwQZuwDFzUEAB42QAAPvAAGH2QgAAEPgAAYAIwBEzQY
AAgIABdmQAAaZjQACAwAARAAH2MIAAMIgAAFBAAIoAAPEAANHmUcAQ8EABpANjAwZoAAEjcEACJm
ZAgAJmEzDAAEGAAnZmYEAAMcACZmZagDJ2EzDAAXYgwAUmEwMGE5IAAJJAASOBgADjQADwQAAxRh
BAADRAAEWAAvZWIEABsXYQwADwQAcgTICAB0Bhoz9AsvYzAEAAADKAAFOAADyAsEUAAvYzgEAAsN
KAAfOQQABwUsAB85BAAIBJgAD6wACAUQAB8w4AAEHzFAABgfMTQADB4xQAAPMAAJL2VhBAAHBEAA
L2VhBAAIH2IEACsiZjMEAAgQAAwcAypmM-ACBAwALmYzMAAEFAAmZWIEAAQgAC5mM0AAKmFhHAAI
FAAvZWJAAAMIKAAvZjMYAAMvYTkUAAcEDAAuZjMcAAQUAC9lYsAACAcQAAwcAAxsAA9AAAEmZWI8
ACpmMxgADywABQgQAARgACZmM0gAImE5HAAMLAAMMAAMZAAPQAABJmFhEAAEFAAmZjMQACZlYjgA
L2ViBAAsH2EAAxciZjIkDiZmYRQAD3AOBSZhMkAAJ2EyJA4aZDQAK2QzRAAfMUAABy5jMWgOL2Ri
eA4AHzFAAAAPAAQEBMwMDAQAJmYxQAAPJAAJI2ZiTAATNAgAFjDUDAVAAAQkABdkCAADJAAE8AwE
OAABCAAfNUAAAAtgACJjMBgABMwMDZwAFzlAAA8kAAgPAAEyCJwAFjScAAVAABNiHAAIBAESNBgA
BRwAFzUgAA8AAQEIJAEDDAAPAAExL2MwBAAIA0AALmMwBAAPAA4KHjZAAA8oAAUEQAoJ3AkeZUAA
DygABS5lY3QKD0AABggoABpmQAAJBAAPQAAIDCgAK2VjlAAfZkAACAgkAAxAAAsYAA9AAAIfZEAA
DB9kQAAUH2RAAAAEVAAPQAANF2YIAARAAAQUAAcYAA9AAAIIKAAXZEAAD8ABLQhYAB9mQAALDCgA
K2VjFAAfZEAADAQkAA_ADAkPAAMAL2Y0gAwHImZmUAwjZTdgDA6AAA8oAAsAxBFIODAwYgQGC0AA
DygAAw8ABRMFYBQeMSASAZwEHjAEACtmYkAAAHgAEzkEAAiAAA-ABBAvYzAEAAcvYjEEAAQWMkAA
CbwADAQAHzkEAAQXYUAACLwADAQAGzAUARMxCAAWMEAABRAAHjAkAC5iOBQBKmIwwAANWAAPUAAI
BVQAH2GAAAgHBAAOFBgPCAAcCAwADwgAIQgMAA8IACEIDAAPCAAhDxQAAR8zCAAEHzgIAAALFAAN
_BoMABsLMAANPAAfYVQCAwk8Chc4CAAPPAAAJmFmBAArYjIcGRs4CAAIDAASMjwCCUAAA5gCD4AA
DQxEAAzUAi9kMQABFw2wCg8AARAIgAAiYzBEABdhDAAPAAESB0QAEGE4AB8xvAAMHzgUAAQLRAAP
vAAGGzQMAB84JBwEHzUgAAQbOAwADwgAICtjMGwBCAQAD0AEEC9lYSANBwRAAC9lYQQAByZjMAQA
I2Q5MAMfYYAAByZkMWABBBQAD8QAAh4xQAAOZAAPBAAMDEAADGQAHjCQHA8IAB0vYzAEAE8PNAEG
C9gADygABQ80ARUOKAAONAENEAAOBAAPLAAbAGwJEzcIAB82EAAEDBQACAwAAEQJE2YIAB9lEAAE
H2UgAAcvZTkEACsAcAEvZTgIACgDDAAPAAQqDmwBD4wBGwhIABswzA4fMAQAAQ9sACMOyAIPBAAY
H2PIAhAEuAAPjAAJA3wQL2MwpAAoHzEYAAcJpAAbYzAADKAAG2QgAA8EACAJpAgEeAAPVAAABZgA
CzAAL2M4BAAsBFgjGjRYIwkEAAwgAAcQACtkNaQJGjWEBgSUBgX4Ahs1EAAIDAALiAgvYzS8Bwwf
OBQAABszAAIPAAgZGzOAAAxUAh84CAAAD7wABQN8ACtjMIAAGjMwAA94AAkIBAAnZDn4AQhMAA54
AA8EAA4JkAAESAALNAEvYzBQAwQbY5AAD7wACC9kMRwADw0gAAdkAwVkAA88AAUeM7wADwQACg_Q
AQEIjAEfMjQABw_AAAYeOEQADzQAChc1PAATNAQAHzgIACgbOFAADAgAHzgIAAwONAAOCAAfOAgA
CBc4xAEfYqQCBAgIABs4CAAIAAIHOAEvZDlMAAgIRAAfM7wBCBIwVAAvZDlEAAgIgAAXMAQAHzHw
AQQIPAAXOBQAHzWIAAcPgAACBAgACzQABWwAHjKIACdjNBQABIgDGmM8ASdkORQAHzAEAAcFaAAI
bAAIYAAHjAMJlAAMaAAbOEQADwQAAA2UABtkgAAPRAABD7wIARtjkAAXODwAC0QAKmQxtAANgAME
MAAIDAAeOCQADxAAAggIAAgMAA8IACAnYzAEAAR4AQ8QAAUPGAABHzgEACwfOQQAKy9lYQQACxtm
lA4MBAAF7AEP7AABHzU8AgAeMBADDwQAGg5sAA4EAAdgAwgEAAlUAgekAA4sAA_oAAMPzAABJmQw
DAQPiAQCCHgAHzgIAAAEJAUEWAAbZMgAD4AEARMwPAAEKAAPBAAJHzVEAAQDCAAvYzCMAQADeAAM
BAArZDmwABNiHAAMQAEITAAA5BAWNLAaAQwBGzCEAQ8EAAwFPBgXZYQAA2gBL2VhBAAPATwYFjdY
GAicEg8EAAYHIAAjZmM0GAcwGA8EAD4fMUABBwlEAhs1CAAfNEwBEwkAAhc4CAAfOFgABBoynAAF
gAAbOAgADhQADggDD4AAEQ88AAgvY2REAAgPPAAFA-gCCAQAD8QAAgcMAw9MAQkFPAALMAAvZTEE
ADAfMjQAOA9MABYPkDAlDwQAlB8yHAAJD9QANw8UAgIaMCQFBQgAH2QwAAAMJAAXY8QCCBQEBAAD
CzAABBwADzAAAQ4UAA8QAAAfNugTCA8UABEP8BMJH2YMAAQHBAAjZDYEABc3DAAMBAAfNyQABy9l
YgQAAyZkZgwADhwADzAABQ8EAB8NUAQPCAAdDxQAAR8wGAAYHjQkAA8sAAYPKAABDxQAAR80GAAU
HzQkABQPIAAJDzwAEQ9EAAkEFAAPCAAFHzQIAAQEIAAIDAAfNDQAFAUYAPEUIiksaGlkZGVuPWZh
bHNlLG5hbWU9Im1hcCIscGFuX3g9LTQJAPICeT0tMTUxMCx0aWxlX2g9MTYKABB3CgCAem9vbT0x
fX0=
:: map/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDEwOjQ5OjA5Iixtb2RpZmllZD0iMjAyNC0x
MC0yMyAyMDozNjowOSJdXQ==
:: sfx/
:: sfx/0.sfx
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDA5OjIxOjQxIixtb2RpZmllZD0iMjAyNC0x
MC0yMyAyMDozNjowOSIscmV2aXNpb249MTAyNl1dbHo0AKUAAAAUCgAA-zBweHUAAygAAAQABA9A
EAIOAAGgASACoA4ADxAADfDKAQIDQA8PkAQFBgdADJAICQoLQAyQDwwPDQ8ODEAM8P8BAOv-J6oB
EAYPIBABIAEgAfAAAhACDhABIA8hIAEwD0Dwww8oD--wxg-4Cg--D4AP9w8NAfAJARAGDjAA----
--_9H-8BAKzPyA9AAA8QQP--sPD-AQD-2B-L9gEHUP----_E
:: sfx/.info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDEwOjQ5OjA5Iixtb2RpZmllZD0iMjAyNC0x
MC0yMyAyMDozNjowOSJdXQ==
:: blob.lua
--[[pod_format="raw",created="2024-10-06 05:10:33",modified="2024-10-21 21:54:39",revision=1006]]
include "dither.lua"

function blob(p)
	local flr_r = flr(p.r)
	local _r = {
		0,
		flr_r * 0.05,
		flr_r * 0.15,
		flr_r * 0.30
	}
	
--	local pat = { -- we can also use dither_mask(value) values instead
--		0b0000000000000000,
--		0b0001101001011010,
--		0b0111111111111111,
--		0b1111111111111111
--	}

	local pat = {
		dither_mask(1),
		dither_mask(9/16),
		dither_mask(1/16),
		dither_mask(0)
	}

	if flr_r <= 5 then
		deli(_r,4)
		deli(_r,2)
		deli(pat,2)
		deli(pat,2)
--	elseif flr_r <= 6 then
--		deli(_r,3)
--		deli(pat,3)
	elseif flr_r <= 8 then
		deli(_r,4)
		deli(pat,3)
		pat[2]=0b1001001001001001	
	elseif flr_r >= 12 then
--		deli(_r,4)
--		deli(pat,3)
--		pat[2]=0b1001001001001001
		_r[2] = flr_r * 0.02
		_r[3] = flr_r * 0.08
		_r[4] = flr_r * 0.12
	end
--	fillp(dither_mask(3/8))
--	fillp(0b0001101001011010)
--	circfill(p.x-2,p.y+2, flr_r, 0x1814) -- adds dark outline
--	circfill(p.x-1,p.y+1, flr_r, 21) -- adds dark outline
	for i = 1, #_r do
--		poke(0x550b,0x3f) -- set black to transparent
--		palt()            -- recommended but what is this doing?
--		fillp(dither_mask(i/#_r))
		fillp(pat[i])
		circfill(p.x, p.y-_r[i], flr_r-_r[i], p.c)
--		poke(0x550b,0x00) -- set back to black
	end
	
	fillp()
	if flr_r == 1 then
		pset(p.x, p.y, p.c)
	elseif flr_r == 2 then
		rectfill(p.x-1, p.y-1, p.x+1, p.y+1, p.c)
	end
end


:: dither.lua
--[[pod_format="raw",created="2024-10-06 20:57:04",modified="2024-10-21 21:56:58",revision=680]]
local threshold_map = {
	0, 8, 2, 10,
	12, 4, 14, 6,
	3, 11, 1, 9,
	15, 7, 13, 5,
}

local function make_mask(value)
	local mask = 0
	for i = 1, 16 do
		mask = mask * 2
		if threshold_map[i] >= value then
			mask += 1
		end
	end
	return mask
end

local dither_masks = {}

for i = 0, 16 do
	dither_masks[i] = make_mask(i)
end

-- value 0-1
function dither_mask(value)
	return dither_masks[mid(0, flr(value * 16 + 0.5), 16)]
end
:: draw.lua
--[[pod_format="raw",created="2024-10-21 21:26:28",modified="2024-10-23 20:36:09",revision=189]]

function drw_game()
	for seg in all(cursegs) do
		map(seg.x, seg.y, xscroll + x_borders, scroll - seg.o, 21, 8)
	end
	
	-- draw borders
	rectfill(0, 0, x_borders, 270, 32)
	rectfill(480, 0, 480 - x_borders, 270, 32)
	
	for p in all(parts) do
		if p.wait == nil then
			p.draw(p)
		end
	end
	
	for s in all(shots) do
		spr(s.sani[flr(s.si)], s.x + 6, s.y)
	end

	for m in all(muzz) do
		spr(m.sani[flr(m.si)], px + m.x, py + m.y)
	end
	
	spr(shiparr[flr(shipspr * 2.4 + 3.5)], px, py)

	local fframe = (t % (#flamearr - 1)) + 1

	spr(flamearr[fframe], px + 6 - banked, py + 14, true)
	spr(flamearr[fframe], px + 2 + banked, py + 14)
end
:: explmain.lua
--[[pod_format="raw",created="2024-10-06 04:41:06",modified="2024-10-23 20:36:09",revision=1084]]
-- [x] flash / contrast flame
-- [ ] fireball
-- [ ] smoke

-- colors for fireball progression
-- white/white 		0x0707		119
-- white/yellow 		0x070a		167
-- yellow/orange 	0x0a09		154
-- orange/yellow 	0x090a		169
-- pgrey/red 		0x0d08		141
-- pgrey/dark grey 0x0d05		93

-- [ ] billowing (fire and smoke)
-- [ ] going up
-- [ ] smoke dissipates
-- [ ] sparks

include "blob.lua"
include "explode.lua"
include "spark.lua"

function _init()
	parts = {}
	slowmo = false
	
	t = 0
end

function _draw()
	cls(12)
	for p in all(parts) do
		if p.wait == nil then
			p.draw(p)
		end
	end
--	print(myblb.r, 236, 250, 7)
--	print(dither_mask(1.1/16), 2, 2, 7)
	print(t, 2, 2, 7)
end

function _update()
	if btnp(4) then
		slowmo = false
		explode(240+rnd(20)-10,135+rnd(20)-10)
	end
	if btnp(5) then
		slowmo = true
		explode(240,135)
		t = 0
	end
	
	if slowmo == false or btnp(1) then
		t+=1
		for p in all(parts) do
			dopart(p)
		end
	end
end

function rndrange(low, high)
	return flr(rnd(high + 1 - low) + low)
end
:: explode.lua
--[[pod_format="raw",created="2024-10-07 01:29:38",modified="2024-10-21 21:56:01",revision=635]]
function explode(ex, ey)
	add(parts, {
		draw = blob,
		x = ex,
		y = ey,
		r = 17,
		maxage = 2,
		c = 0x0707,
		ctab = {0x0707,0x070a},
	})
	
	sparkblast(ex, ey, 2)
	sparkblast(ex, ey, 15)
	
	grape(ex, ey, 2, 13, 1, "return", 
		{0x070a,0x070a,0x070a,0x0a09},
		0)
	grape(ex+rnd(5)-2.5, ey - 5, 10, 20, 1, "return", 
		{0x070a,0x0a09,0x090a},
		-0.2)
	grape(ex+rnd(5)-2.5, ey - 10, 25, 25, .2, "fade", 
		{0x070a,0x070a,0x0a09,0x090a,0x0d08,0x0d05},
		-0.3)
end

function dopart(p)
	-- [ ] age function
	-- [ ] max age counter

	if p.wait then
		-- wait countdown
		p.wait -= 1
		if p.wait <= 0 then
			p.wait = nil
			if p.c == nil and p.ctab then
				p.c = p.ctab[1]
			end
		end
	else
		-- particle logic
		p.age = p.age or 0
		if p.age == 0 then
			p.ox = p.x
			p.oy = p.y
			p.r = p.r or 1
			p.ctabv = p.ctabv or 0
		end
		
		p.age += 1
		-- animate color
		if p.ctab then
			local life = (p.age + p.ctabv) / p.maxage
			local i = mid(1, flr(1 + life * #p.ctab), #p.ctab)
			p.c = p.ctab[i]
		end

		-- movement
		if p.to_x then
			p.x += (p.to_x - p.x) / (4 / p.spd)
			p.y += (p.to_y - p.y) / (4 / p.spd)
		end
		
		if p.sx then
			p.x += p.sx
			p.y += p.sy
			if p.to_x then
				p.to_x += p.sx
				p.to_y += p.sy
			end
			if p.drag then
				p.sx *= p.drag
				p.sy *= p.drag
			end
		end
		
		-- size
		if p.to_r then
			p.r += (p.to_r - p.r) / (5 / p.spd)
		end
		
		if p.sr then
			p.r += p.sr
		end
		
	
		if p.age >= p.maxage or p.r < 0.5 then
	      if p.onend == "return" then
	        p.maxage += 32000
	        p.to_x = p.ox
	        p.to_y = p.oy
	        p.to_r = nil
	        p.sr = -0.3
			elseif p.onend == "fade" then
	        p.maxage += 32000
	        p.to_r = nil
	        p.sr = -0.1 - rnd(0.3)
	      else
	        del(parts, p)
	      end
	      p.ctab = nil
	      p.onend = nil
		end
	end
	-- 2 main ways to logic and animate
	-- sx/sy velocity system.  not great control if you want control over the particles final destination
	-- to_x/to_y destination definition
end

function grape(ex, ey, ewait, emaxage, espd, eonend, ectab, edrift)
	local spokes = 6
	local ang = rnd()
	local step = 1 / spokes
	local shakiness = rnd(3) - 1.5

	-- spawn spokes
	for i = 1, spokes do
		local myang = ang + step * i
		local dist = 8 + shakiness
		local dist2 = dist / 2
		local temp_ox = shakiness + ex + sin(myang) * dist2
		local temp_oy = shakiness + ey + cos(myang) * dist2

		add(parts, {
			draw = blob,
			x = temp_ox,
			y = temp_oy,
			ox = temp_ox,
			oy = temp_oy,
			r = 3,
			to_r = rndrange(3,7),
			to_x = shakiness + ex + sin(myang) * dist,
			to_y = shakiness + ey + cos(myang) * dist,
			sx = 0,
			sy = edrift,
			spd = espd or 1,
			wait = ewait,
			maxage = emaxage,
    		onend = eonend,
    		c = ectab[1],
    		ctab = ectab,
    		ctabv = rnd(4),
		})
	end
	-- spawn center
	add(parts, {
		draw = blob,
		x = shakiness + ex,
		y = shakiness + ey - 2,
		r = 3,
		to_r = rndrange(6,9),
		sx = 0,
		sy = edrift,
		spd = espd or 1,
		wait = ewait,
		maxage = emaxage,
    	onend = eonend,
    	c = ectab[1],
   		ctab = ectab,
	})
end

:: gameplay.lua
--[[pod_format="raw",created="2024-10-21 21:26:48",modified="2024-10-23 20:36:09",revision=177]]
function doshots()
	for s in all(shots) do
		s.x = s.x + s.sx
		s.y = s.y + s.sy
		s.si = s.si + 0.5

		if flr(s.si) > #s.sani then
			s.si = 1
		end
		if s.y < -16 then
			del(shots, s)
		end
	end
end

function shoot()
	local shotspd = -12
	shotwait = 3
	add(shots, {
		x = px - 6,
		y = py,
		sx = 0,
		sy = shotspd,
		sani = { 24, 25, 26, 25 },
		si = t % 4 + 1,
	})
	add(shots, {
		x = px + 2,
		y = py,
		sx = 0,
		sy = shotspd,
		sani = { 24, 25, 26, 25 },
		si = t % 4 + 1,
	})
	add(muzz, {
		x = -4,
		y = -8,
		sani = { 27, 28, 29, 30 },
		si = 0,
	})
	add(muzz, {
		x = 4,
		y = -8,
		sani = { 27, 28, 29, 30 },
		si = 0,
	})
end
:: main.lua
--[[pod_format="raw",created="2024-09-22 09:21:41",modified="2024-10-23 20:36:09",revision=1428]]
---@diagnostic disable-next-line: undefined-global
include("tools.lua")
include("draw.lua")
include("update.lua")
include("gameplay.lua")
include("particles.lua")
include("profiler.lua")

function _init()
	profile("_init")
	t = 0
	profile.enabled(true,true)
	
	butdic = { -- 0 - stop
		1, -- 1  - left
		2, -- 2  - right
		0, -- 3  - stop l+r
		3, -- 4  - up
		5, -- 5  - diag u+l
		6, -- 6  - diag u+r
		3, -- 7  - up u+l+r
		4, -- 8  - down
		8, -- 9  - diag d+l
		7, -- 10 - diag d+r
		4, -- 11 - down r+l+d
		0, -- 12 - stop u+d
		1, -- 13 - left l+u+d
		2, -- 14 - right r+u+d
		0, -- 15 - stop l+r+u+d
	}
	butdic[0] = 0
	dirx = { -1, 1,  0, 0, -0.75,  0.75, 0.75, -0.75 }
	diry = {  0, 0, -1, 1, -0.75, -0.75, 0.75,  0.75 }
	
	x_borders = 132
	-- 216px horizontal space mirrors 5:4 tate at 270:216
	-- on a 480px wide display, this would require two padding sections at 132px each
	
	-- BUGFIX: dummy segment needed at start
	
	shiparr = { 8, 9, 10, 11, 12 }
	flamearr = { 17, 18, 17, 19, 18, 20, 19, 21 }
	-- lazydevs segs 3,3,3,3,3,2,1,0,1,7,6,5,10,4,11,6,11,11,5,9,10,8,1,0,15,14,1,13,12,19,19,18,17,16,18,17,16,17,16,19,22,21,20,27,26,25,23,24,3,3
	mapsegs = {0,3,3,3,3,3,2,1,28,1,7,6,5,10,4,11,6,11,11,5,9,10,8,1,28,14,15,1,12,13,19,19,16,17,18,16,17,18,17,18,19,20,21,22,23,24,25,26,27,3,3,3}
	
	startgame()
end

function _draw()
	_drw()	
-- debug
-- print(px, 2, 2, 7)
--	print(scroll, 2, 11, 7)
--	print(xscroll, 2, 20, 7)
--	print(boss and "boss" or "no boss", 2, 29, 7)
end

function _update()
	_upd()
end

function startgame()
	px, py = 240, 135
	spd = 1.537
	lastdir = 0
	shipspr = 0
	
	scroll = 11
	xscroll = 0
	mapsegi = 1
	seglib = {}
	cursegs = {}
	
	boss = false
	
	parts = {}
	shots = {}
	shotwait = 0
	muzz = {}
	banked = 0
	
	_upd = upd_game
	_drw = drw_game
end
:: moveandshoot.lua
--[[pod_format="raw",created="2024-10-13 21:18:38",modified="2024-10-21 21:27:08",revision=487]]

:: particles.lua
--[[pod_format="raw",created="2024-10-21 21:26:56",modified="2024-10-23 20:36:09",revision=175]]
function blob(p)
	local flr_r = flr(p.r)
	local _r = {
		0,
		flr_r * 0.05,
		flr_r * 0.15,
		flr_r * 0.30
	}
	
--	local pat = { -- we can also use dither_mask(value) values instead
--		0b0000000000000000,
--		0b0001101001011010,
--		0b0111111111111111,
--		0b1111111111111111
--	}

	local pat = {
		dither_mask(1),
		dither_mask(9/16),
		dither_mask(1/16),
		dither_mask(0)
	}

	if flr_r <= 5 then
		deli(_r,4)
		deli(_r,2)
		deli(pat,2)
		deli(pat,2)
--	elseif flr_r <= 6 then
--		deli(_r,3)
--		deli(pat,3)
	elseif flr_r <= 8 then
		deli(_r,4)
		deli(pat,3)
		pat[2]=0b1001001001001001	
	elseif flr_r >= 12 then
--		deli(_r,4)
--		deli(pat,3)
--		pat[2]=0b1001001001001001
		_r[2] = flr_r * 0.02
		_r[3] = flr_r * 0.08
		_r[4] = flr_r * 0.12
	end
--	fillp(dither_mask(3/8))
--	fillp(0b0001101001011010)
--	circfill(p.x-2,p.y+2, flr_r, 0x1814) -- adds dark outline
--	circfill(p.x-1,p.y+1, flr_r, 21) -- adds dark outline
	for i = 1, #_r do
--		poke(0x550b,0x3f) -- set black to transparent
--		palt()            -- recommended but what is this doing?
--		fillp(dither_mask(i/#_r))
		fillp(pat[i])
		circfill(p.x, p.y-_r[i], flr_r-_r[i], p.c)
--		poke(0x550b,0x00) -- set back to black
	end
	
	fillp()
	if flr_r == 1 then
		pset(p.x, p.y, p.c)
	elseif flr_r == 2 then
		rectfill(p.x-1, p.y-1, p.x+1, p.y+1, p.c)
	end
end

function explode(ex, ey)
	add(parts, {
		draw = blob,
		x = ex,
		y = ey,
		r = 17,
		maxage = 2,
		c = 0x0707,
		ctab = {0x0707,0x070a},
	})
	
	sparkblast(ex, ey, 2)
	sparkblast(ex, ey, 15)
	
	grape(ex, ey, 2, 13, 1, "return", 
		{0x070a,0x070a,0x070a,0x0a09},
		0)
	grape(ex+rnd(5)-2.5, ey - 5, 10, 20, 1, "return", 
		{0x070a,0x0a09,0x090a},
		-0.2)
	grape(ex+rnd(5)-2.5, ey - 10, 25, 25, .2, "fade", 
		{0x070a,0x070a,0x0a09,0x090a,0x0d08,0x0d05},
		-0.3)
end

function dopart(p)
	-- [ ] age function
	-- [ ] max age counter

	if p.wait then
		-- wait countdown
		p.wait -= 1
		if p.wait <= 0 then
			p.wait = nil
			if p.c == nil and p.ctab then
				p.c = p.ctab[1]
			end
		end
	else
		-- particle logic
		p.age = p.age or 0
		if p.age == 0 then
			p.ox = p.x
			p.oy = p.y
			p.r = p.r or 1
			p.ctabv = p.ctabv or 0
		end
		
		p.age += 1
		-- animate color
		if p.ctab then
			local life = (p.age + p.ctabv) / p.maxage
			local i = mid(1, flr(1 + life * #p.ctab), #p.ctab)
			p.c = p.ctab[i]
		end

		-- movement
		if p.to_x then
			p.x += (p.to_x - p.x) / (4 / p.spd)
			p.y += (p.to_y - p.y) / (4 / p.spd)
		end
		
		if p.sx then
			p.x += p.sx
			p.y += p.sy
			if p.to_x then
				p.to_x += p.sx
				p.to_y += p.sy
			end
			if p.drag then
				p.sx *= p.drag
				p.sy *= p.drag
			end
		end
		
		-- size
		if p.to_r then
			p.r += (p.to_r - p.r) / (5 / p.spd)
		end
		
		if p.sr then
			p.r += p.sr
		end
		
	
		if p.age >= p.maxage or p.r < 0.5 then
	      if p.onend == "return" then
	        p.to_x = p.ox
	        p.to_y = p.oy
	        p.to_r = nil
	        p.sr = -0.3
			elseif p.onend == "fade" then
	        p.to_r = nil
	        p.sr = -0.1 - rnd(0.3)
	      else
	        del(parts, p)
	      end
	      p.ctab = nil
	      p.onend = nil
	      p.maxage = 32000
		end
	end
	-- 2 main ways to logic and animate
	-- sx/sy velocity system.  not great control if you want control over the particles final destination
	-- to_x/to_y destination definition
end

function grape(ex, ey, ewait, emaxage, espd, eonend, ectab, edrift)
	local spokes = 6
	local ang = rnd()
	local step = 1 / spokes
	local shakiness = rnd(3) - 1.5

	-- spawn spokes
	for i = 1, spokes do
		local myang = ang + step * i
		local dist = 8 + shakiness
		local dist2 = dist / 2
		local temp_ox = shakiness + ex + sin(myang) * dist2
		local temp_oy = shakiness + ey + cos(myang) * dist2

		add(parts, {
			draw = blob,
			x = temp_ox,
			y = temp_oy,
			ox = temp_ox,
			oy = temp_oy,
			r = 3,
			to_r = rndrange(3,7),
			to_x = shakiness + ex + sin(myang) * dist,
			to_y = shakiness + ey + cos(myang) * dist,
			sx = 0,
			sy = edrift,
			spd = espd or 1,
			wait = ewait,
			maxage = emaxage,
    		onend = eonend,
    		c = ectab[1],
    		ctab = ectab,
    		ctabv = rnd(4),
		})
	end
	-- spawn center
	add(parts, {
		draw = blob,
		x = shakiness + ex,
		y = shakiness + ey - 2,
		r = 3,
		to_r = rndrange(6,9),
		sx = 0,
		sy = edrift,
		spd = espd or 1,
		wait = ewait,
		maxage = emaxage,
    	onend = eonend,
    	c = ectab[1],
   		ctab = ectab,
	})
end

function spark(p)
	-- pset(p.x, p.y, 8)
	line(p.x, p.y, p.x - p.sx * 2, p.y - p.sy * 2, 7)
	line(p.x+1, p.y, p.x + p.sx * 2 + 1, p.y + p.sy * 2, p.c)
end

function sparkblast(ex, ey, ewait)
	local ang = rnd()	
	for i = 1,6 do
		local ang2 = ang+rnd(0.5)
		local spd = rndrange(4,8)
		add(parts, {
			draw = spark,
			x = ex,
			y = ey,
			sx = sin(ang2)*spd,
			sy = cos(ang2)*spd,
			drag = 0.8,
			wait = ewait,
			maxage = rndrange(8,20),
			c = 10,
			ctab = {7, 10},
		})
	end
end

function domuzz()
	for m in all(muzz) do
		m.si = m.si + 1

		if flr(m.si) > #m.sani then
			del(muzz, m)
		end
	end
end
:: profiler.lua
--[[pod_format="raw",created="2024-09-20 18:19:15",modified="2024-10-23 20:36:09",revision=67]]
-- abledbody's profiler v1.1

local function do_nothing() end

-- The metatable here is to make profile() possible.
-- Why use a table at all? Because otherwise lua will try to cache the function call,
-- which by default is do_nothing.
local profile_meta = {__call = do_nothing}
profile = {draw = do_nothing}
setmetatable(profile,profile_meta)

local running = {} -- All incomplete profiles
 -- All complete profiles. Note that if the profiles haven't been drawn yet, it will
 -- not be cleared, and further profiles of the same name will add to the usage metric.
local profiles = {}
-- All completed lingering profiles. These are never automatically cleared.
local lingers = {}

-- start_profile, stop_profile, and stop_linger are all internal functions,
-- serving as paths for _profile to take. Lingers share start_profile.
local function start_profile(name,linger)
	local source = profiles[name]
	running[name] = {
		linger = linger,
	}
	local active = running[name]
	active.start = stat(1) --Delaying CPU usage grab until the last possible second.
end

local function stop_profile(name,active,delta)
	local profile = profiles[name]
	if profile then
		profile.time = delta+profile.time
	else
		profiles[name] = {
			time = delta,
			name = name,
		}
		add(profiles,profiles[name])
	end
end

local function stop_linger(name,active,delta)
	local profile = lingers[name]
	if profile then
		profile.time = profile.this_frame and delta+profile.time or delta
		profile.this_frame = true
	else
		lingers[name] = {
			time = delta,
			this_frame = true,
		}
	end
end

-- The main functionality lives here.
-- Takes in the name of what you're profiling, and whether or not to
-- make the profile linger.
local function _profile(_,name,linger)
	local t = stat(1)
	local active = running[name]
	if active then
		local delta = t-active.start

		if active.linger then stop_linger(name,active,delta)
		else stop_profile(name,active,delta) end

		running[name] = nil
	else
		start_profile(name,linger)
	end
end

-- Clears all lingering profiles.
function profile.clear_lingers()
	lingers = {}
end

local function draw_cpu()
	print("cpu:"..string.sub(stat(1)*100,1,5).."%",1,1,7)
end

-- This draws the profiles, and then resets everything for the next frame.
-- If it is not called, usage metrics will accumulate.
-- Lingering profiles are always displayed after persistent profiles.
local function display_profiles()
	local i = 1
	for prof in all(profiles) do
		local usage = string.sub(prof.time*100,1,5).."%"
		local to_print = prof.name..":"..usage
		print(to_print,1,1+i*9,7)
		i = i+1
	end
	for name,prof in pairs(lingers) do
		local usage = string.sub(prof.time*100,1,5).."%"
		local to_print = name..(prof.this_frame and "[X]:" or "[ ]:")..usage
		print(to_print,1,1+i*9,7)
		prof.this_frame = false
		i = i+1
	end
	profiles = {}
end

local function display_both()
	draw_cpu()
	display_profiles()
end

-- This swaps out function calls depending on whether or not you want to have
-- profiling. This is to make it as much as possible so that you don't have to
-- think about cleaning up profile calls for efficiency.
-- The first boolean is for detailed profiling, the second is for CPU usage.
function profile.enabled(detailed,cpu)
	profile_meta.__call = detailed and _profile or do_nothing
	profile.draw = detailed and (cpu and display_both or display_profiles)
		or (cpu and draw_cpu or do_nothing)
end
:: spark.lua
--[[pod_format="raw",created="2024-10-13 19:34:29",modified="2024-10-21 21:55:32",revision=192]]
function spark(p)
	-- pset(p.x, p.y, 8)
	line(p.x, p.y, p.x - p.sx * 2, p.y - p.sy * 2, 7)
	line(p.x+1, p.y, p.x - p.sx * 2 + 1, p.y - p.sy * 2, p.c)
end

function sparkblast(ex, ey, ewait)
	local ang = rnd()	
	for i = 1,6 do
		local ang2 = ang+rnd(0.5)
		local spd = rndrange(4,8)
		add(parts, {
			draw = spark,
			x = ex,
			y = ey,
			sx = sin(ang2)*spd,
			sy = cos(ang2)*spd,
			drag = 0.8,
			wait = ewait,
			maxage = rndrange(8,20),
			c = 10,
			ctab = {7, 10},
		})
	end
end
:: tools.lua
--[[pod_format="raw",created="2024-10-21 21:26:41",modified="2024-10-23 20:36:09",revision=170]]
-- alternate to sgn, different in that 0 returns 0 instead of 1
function mysgn(v)
	return v == 0 and 0 or sgn(v)
end

-- for a value x between range in_min and in_max, map the value at the same
-- relational position between out_min and out_max
function map_range(x, in_min, in_max, out_min, out_max)
	return out_min + (x - in_min) * (out_max - out_min) / (in_max - in_min)
end

-- returns a random value inclusively between low and high
function rndrange(low, high)
	return flr(rnd(high + 1 - low) + low)
end

-- dither mask suite
local threshold_map = {
	0, 8, 2, 10,
	12, 4, 14, 6,
	3, 11, 1, 9,
	15, 7, 13, 5,
}

local function make_mask(value)
	local mask = 0
	for i = 1, 16 do
		mask = mask * 2
		if threshold_map[i] >= value then
			mask += 1
		end
	end
	return mask
end

local dither_masks = {}

for i = 0, 16 do
	dither_masks[i] = make_mask(i)
end

-- value 0-1
function dither_mask(value)
	return dither_masks[mid(0, flr(value * 16 + 0.5), 16)]
end
:: update.lua
--[[pod_format="raw",created="2024-10-21 21:26:35",modified="2024-10-23 20:36:09",revision=200]]
function upd_game()
	profile("_update")
	t = t + 1

	-- SCROLLING
	scroll = scroll + 0.5

	if #cursegs < 1 or scroll - cursegs[#cursegs].o > 0 then
		if boss then
			scroll = scroll - 128
			for seg in all(cursegs) do
				seg.o = seg.o - 128
			end
		else
			mapsegi = mapsegi + 1
		end

		local segnum = mapsegs[mapsegi] or 0

		add(cursegs, {
			x = 0,
			y = 248 - ((segnum - 1) * 8),
			o = #cursegs < 1 and -128 or cursegs[#cursegs].o + 128,
		})

		if scroll - cursegs[1].o >= 384 then
			deli(cursegs, 1)
		end
	end

	-- INPUTS / MOVEMENT
	local dir = butdic[btn() & 0b1111]

	if lastdir ~= dir and dir >= 5 then
		px = flr(px) -- or flr(px) + 0.5
		py = flr(py) -- or flr(py) + 0.5
	end

	local dshipspr = 0
	banked = 0

	if dir > 0 then
		px = px + dirx[dir] * spd
		py = py + diry[dir] * spd

		dshipspr = mysgn(dirx[dir])
		banked = 1
	end

	shipspr = shipspr + mysgn(dshipspr - shipspr) * 0.18
	shipspr = mid(-1, shipspr, 1)

	lastdir = dir

	-- boundary checking
	if px < x_borders then
		px = x_borders
	end
	if px > 480 - x_borders - 15 then
		px = 480 - x_borders - 15 -- 15 is sprite size with an offset
	end

	percentage_scrolled = mid(6 / 32, (px - x_borders - 3) / 201, 26 / 32)
	xscroll = map_range(percentage_scrolled * -32, -26, -6, -40, 0)

	-- shooting
	if shotwait > 0 then
		shotwait = shotwait - 1
	else
		if btn(4) then
			shoot()
		end
	end

	-- dokaaaaaaaaaan!!!
	if btnp(5) then
		explode(40,135)
	end

	doshots()
	domuzz()
	for p in all(parts) do
		dopart(p)
	end
	profile("_update")
end

function myupdate()
	cls(11)
end
:: .info.pod
b64$LS1bW3BvZCxjcmVhdGVkPSIyMDI0LTA5LTIyIDA5OjIyOjM5Iixtb2RpZmllZD0iMjAyNC0x
MC0yMyAyMDozNjowOSIscnVudGltZT0xMSx3b3Jrc3BhY2VzPXt7bG9jYXRpb249Im1haW4ubHVh
IzgyIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xvY2F0aW9uPSJkcmF3Lmx1YSMzMCIsd29ya3NwYWNl
X2luZGV4PTF9LHtsb2NhdGlvbj0idXBkYXRlLmx1YSMxIix3b3Jrc3BhY2VfaW5kZXg9MX0se2xv
Y2F0aW9uPSJ0b29scy5sdWEjNDEiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImdhbWVw
bGF5Lmx1YSM0MSIsd29ya3NwYWNlX2luZGV4PTF9LHtsb2NhdGlvbj0icGFydGljbGVzLmx1YSMy
MjgiLHdvcmtzcGFjZV9pbmRleD0xfSx7bG9jYXRpb249ImV4cGxtYWluLmx1YSM1NCIsd29ya3Nw
YWNlX2luZGV4PTF9LHtsb2NhdGlvbj0icHJvZmlsZXIubHVhIzg5Iix3b3Jrc3BhY2VfaW5kZXg9
MX0se2xvY2F0aW9uPSJnZngvMC5nZngiLHdvcmtzcGFjZV9pbmRleD0yfSx7bG9jYXRpb249Im1h
cC8wLm1hcCIsd29ya3NwYWNlX2luZGV4PTN9LHtsb2NhdGlvbj0ic2Z4LzAuc2Z4Iix3b3Jrc3Bh
Y2VfaW5kZXg9NH19XV0=
:: [eoc]
